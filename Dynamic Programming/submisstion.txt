Perfect Squares 
Given a positive integer n, find the least number of perfect square numbers (for example, 1, 4, 9, 16, ...) which sum to n.For example, given n = 12, return 3 because 12 = 4 + 4 + 4; given n = 13, return 2 because 13 = 4 + 9.
Credits:Special thanks to @jianchao.li.fighter for adding this problem and creating all test cases.

class Solution {
public:
    //使用递归
    int numSquares(int n) {
        double square = sqrt(n);
        square = (int)square;
        return _numSquare(n, square);
    }
    /*
    //超时
    int _numSquare(int n, int begin){
        if(begin*begin == n)
            return 1;
        if(begin == 1)
            return n;
        else{
            if(begin*begin < n){
                return min(_numSquare(n-begin*begin, begin) +1, _numSquare(n, begin-1));
            }
            else{
                return _numSquare(n, begin-1);
            }
        }
            
    }
    */
    /*
    //内存不够
        int _numSquare(int n, int begin){
        int** f = new int*[begin+1];
		for(int a=0; a<=begin; a++)
			f[a] = new int[n+1];
         for(int j=1; j<=n; j++){
            f[1][j] = j;
           
        }
        for(int b=1; b<=begin; b++)
			 f[b][0] = 0;
        
        for(int i=2; i<=begin; i++)
            for(int j=1; j<=n; j++){
                if(i*i<=j)
                    f[i][j] = f[i][j-i*i]+1 > f[i-1][j]? f[i-1][j]:f[i][j-i*i]+1;
                else
                    f[i][j] = f[i-1][j];
            }
     return f[begin][n];
    }
    */
    //采用滚动数组
    	int _numSquare(int n, int begin){
        int* f = new int[n+1];
		
        for(int j=0; j<=n; j++){
            f[j] = j;
           
        }
        for(int i=2; i<=begin; i++)
            for(int j=1; j<=n; j++){
                if(i*i<=j)
                    f[j] = f[j-i*i]+1 > f[j]? f[j]:f[j-i*i]+1;
                else
                    f[j] = f[j];
            }
     return f[n];
    
    }
    
}


Ugly Number II 
Write a program to find the n-th ugly number.Ugly numbers are positive numbers whose prime factors only include 2, 3, 5. For example, 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 is the sequence of the first 10 ugly numbers.Note that 1 is typically treated as an ugly number.  The naive approach is to call isUgly for every number until you reach the nth one. Most numbers are not ugly. Try to focus your effort on generating only the ugly ones.  An ugly number must be multiplied by either 2, 3, or 5 from a smaller ugly number.  The key is how to maintain the order of the ugly numbers. Try a similar approach of merging from three sorted lists: L1, L2, and L3.  Assume you have Uk, the kth ugly number. Then Uk+1 must be Min(L1 * 2, L2 * 3, L3 * 5).
Credits:Special thanks to @jianchao.li.fighter for adding this problem and creating all test cases.

class Solution {
public:
    //因为没有通项公司所以只能从一开始一个个的求，直遍1~n的话，会超时，因为有很多的数值不是ugly number，所以最好的方法
    //就是直接的根据前一个ugly number求出求出下一个值，这样就可以不用绕开不是ugly number的值了。
    //方法：后面的ugly number 都是前面的ugly number乘以2或3或5得到的，设置三个变量idx2、idx3、idx5存储下标，初始值都为0
    //找出数组uglyNumbers[idx2]*2、uglyNumbers[idx3]*3、uglyNumbers[idxe]*5的最小值，最小值即为下一个丑数，
    //同时更新最小值对应的下标，如果多个数字同时为最小值，则它们的下标都要更新(整个过程相当于每一个丑数都可乘以2、3、5得到下一个丑数，
    //每次选取最小的丑数作为新的丑数，如果丑数a乘以2得到当前最新的丑数，那么a不能再乘以2了，所以index2++)
    int nthUglyNumber(int n) {
        int *uglyNumber = new int[n];
        uglyNumber[0] = 1;
        int index2 = 0;
        int index3 = 0;
        int index5 = 0;
        int count = 1;
        while(count<n){
            int next = getMin(uglyNumber[index2]*2, uglyNumber[index3]*3, uglyNumber[index5]*5);
            if(next == uglyNumber[index2]*2)
                index2++;
            if(next == uglyNumber[index3]*3)
                index3++;
            if(next == uglyNumber[index5]*5)
                index5++;
            uglyNumber[count] = next;
            count++;
        }
        return uglyNumber[count-1];
    }
    
    int getMin(int a, int b, int c){
        int temp = a>b?b:a;
        if(c<temp)
            return c;
        return temp;
    }
}


Maximal Square 
Given a 2D binary matrix filled with 0's and 1's, find the largest square containing all 1's and return its area.For example, given the following matrix:1 0 1 0 01 0 1 1 11 1 1 1 11 0 0 1 0Return 4.
Credits:Special thanks to @Freezen for adding this problem and creating all test cases.

class Solution {
public:
    //采用递归的方法，以左上角的元素作为矩阵的开始元素，如果左上角(i,j))的元素为0，那么该矩阵的square最大值为(i,j+1)和(i+1, j)矩阵的最大值。
    //采用备忘录的方法，减少递归的次数。
    int maximalSquare(vector<vector<char>>& matrix) {
        if(matrix.size() == 0)
            return 0;
        int row = matrix.size();
        int col = matrix[0].size();
        int **f = new int*[row];
        for(int i=0; i<row; i++)
            f[i] = new int[col];
        for(int i=0; i<row-1; i++)
            for(int j=0; j<col-1; j++)
                f[i][j] = -1;
        f[row-1][col-1] = matrix[row-1][col-1]-'0';
        for(int i=row-2; i>=0; i--){
            if(matrix[i][col-1] == '1')
                f[i][col-1] = 1;
            else
                f[i][col-1] = f[i+1][col-1];
            
        }
        for(int i=col-2; i>=0; i--){
            if(matrix[row-1][i] == '1')
                f[row-1][i] = 1;
            else
                f[row-1][i] = f[row-1][i+1];
            
        }
        _maximalSquare(matrix, f, 0, 0);
        
        return f[0][0];
        
    }
    
    void _maximalSquare(vector<vector<char>>& matrix, int **f, int row, int col){
        if(f[row][col] != -1)
            return;
        
        if(matrix[row][col] == '0'){
            if(f[row][col+1] == -1){
                _maximalSquare(matrix, f, row, col+1);
            }
            if(f[row+1][col] == -1){
                _maximalSquare(matrix, f, row+1, col);
            }
            f[row][col] = f[row][col+1]>f[row+1][col]? f[row][col+1]: f[row+1][col];
        }
        else{
            int startRow = row; 
            int startCol = col;
            int square = 1;
            bool isSquare = true;
            int count = (matrix.size()-startRow)>(matrix[0].size()-startCol)? (matrix[0].size()-startCol): (matrix.size()-startRow);
            for(int i=1; i<count; i++){
                startRow = row; 
                startCol = col;
                for(; startCol<=col+i; startCol++){
                    if(matrix[row+i][startCol]-'0' != 1){
                        isSquare = false;
                        break;
                    }
                }
                for(; startRow<=row+i && isSquare; startRow++){
                    if(matrix[startRow][col+i]-'0' != 1){
                        isSquare = false;
                        break;
                    }
                }
                if(isSquare)
                    square++;
                else
                    break;
            }
            if(f[row][col+1] == -1){
                _maximalSquare(matrix, f, row, col+1);
            }
            if(f[row+1][col] == -1){
                _maximalSquare(matrix, f, row+1, col);
            }
            square *= square;
            f[row][col] = f[row][col+1]>f[row+1][col]? f[row][col+1]: f[row+1][col];
            f[row][col] = f[row][col]>square? f[row][col]: square;
        }
            
    }
    
}


House Robber II 

Note: This is an extension of House Robber.After robbing those houses on that street, the thief has found himself a new place for his thievery so that he will not get too much attention. This time, all houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, the security system for these houses remain the same as for those in the previous street. Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.
Credits:Special thanks to @Freezen for adding this problem and creating all test cases.

class Solution {
public:

    //动态规划方法,跟第一个问题不同的是这里的数组是环结构，那么从0到n-1开始偷的时候
    //最后的值有四种结果：0和n-1都不偷、0和n-1都偷、0和n-1中只偷一个0和n-1都偷的情况是
    //不允许的，所以这种情况可以不用考虑，那么对于剩下的三种，只需要求出最大的值就好，
    //如果从0到n-1时，0和n-1都不偷，那么在头部或者是尾部去掉0或是n-1对结果没有影响，
    //对于偷0的情况，去掉n-1也不对结果造成影响，
    //只偷n-1的情况下，去掉0也不对结果造成影响
    //所以最后的结论就是去掉0，求剩下的的最大值，去掉n-1，求剩下的最大值，两个最大值中选最大的
    //就是结果的值
    int rob(vector<int>& nums) {
        if(nums.size() == 0)
            return 0;
        if(nums.size() == 1)
            return nums[0];
        int ret = 0;
        int n = nums.size();
        ret = rob(nums, 1, n-1);
        int temp = rob(nums, 0, n-2);
        if(ret<temp)
            ret = temp;
        return ret;
    }
    
    //利用动态规划的方法，返回从begin到end的最大财富的值
    int rob(vector<int>&nums, int begin, int end){
        if(begin == end)
            return nums[begin];
        int i_1 = nums[begin]> nums[begin+1]? nums[begin]: nums[begin+1];
        int i_2 = nums[begin];
        for(int i=begin+2; i<=end; i++){
            if(nums[i]+i_2 > i_1){
                int temp = i_1;
                i_1 = nums[i]+i_2;
                i_2 = temp;
            }
            else{
                i_2 = i_1;
            }
        }
        return i_1;
    }
}


House Robber 
You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night.Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.
Credits:Special thanks to @ifanchu for adding this problem and creating all test cases. Also thanks to @ts for adding additional test cases.

class Solution {
public:
    int rob(vector<int>& nums) {
        //采用的是直接递归
       /*
       return _rob(nums, 0);
       */
       
       //采用的是备忘录
       /*
       int *record = new int[nums.size()+2];
       for(int i=0; i<nums.size()+2; i++)
           record[i] = -1;
       return  _rob(nums, 0, record);
       */
       
       //可以采用备忘录就可以采用动态规划，下面采用的是动态规划的方法
       if(nums.size() == 0)
           return 0;
       if(nums.size() == 1)
           return nums[0];
       int *f = new int[nums.size()];
       f[nums.size()-1] = nums[nums.size()-1];
       f[nums.size()-2] = nums[nums.size()-1]>nums[nums.size()-2]?nums[nums.size()-1]:nums[nums.size()-2];
       for(int i=nums.size()-3; i>=0; i--){
           f[i] = (nums[i]+f[i+2])>f[i+1]?(nums[i]+f[i+2]):f[i+1];
       }
       return f[0];
    }
   //直接采用递归会超时.
   /*
    int _rob(vector<int> &nums, int start){
        if(start >= nums.size())
            return 0;
        int amount1 = nums[start]+_rob(nums, start+2);
        int amount2 = _rob(nums, start+1);
        return amount1>amount2? amount1: amount2;
    }
    */
    
    //采用备忘录,不会超时
    /*
    int _rob(vector<int> &nums, int start, int *record){
        if(start >= nums.size())
            return 0;
        if(record[start+2] == -1){
            record[start+2] = _rob(nums, start+2, record);
        }
        if(record[start+1] == -1)
            record[start+1] = _rob(nums, start+1, record);
        int amount1 = nums[start]+record[start+2];
        int amount2 = record[start+1];
        return amount1>amount2? amount1: amount2;
    }
    */
    
   
}


Best Time to Buy and Sell Stock IV 
Say you have an array for which the ith element is the price of a given stock on day i.Design an algorithm to find the maximum profit. You may complete at most k transactions.
Note:You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).
Credits:Special thanks to @Freezen for adding this problem and creating all test cases.

class Solution {
public:
    /*
    //动态规划
    //24ms
    int maxProfit(int k, vector<int>& prices) {
        if(prices.size() <= 1)
            return 0;
        //存储所有的上升的价格区间的起始下标和终止下标，
        vector<pair<int, int>> asc;
        int start=-1, end = -1;
        for(int i=1; i<prices.size(); i++){
            if(start == -1 && prices[i]<=prices[i-1])
                continue;
            if(start == -1 && prices[i]>prices[i-1])
                start = i-1;
            else if(prices[i]<prices[i-1])
                end = i-1;
            if(start != -1 && end != -1){
                asc.emplace_back(start, end);
                start = -1;
                end = -1;
            }
        }
        if(start != -1)
            asc.emplace_back(start, prices.size()-1);
        if(asc.size() == 0)
            return 0;
        //这一步判断很重要，对于k大于等于asc.size()时，可以直接的将所有获利的都加进去，得到最大的利润
        //没有这一步判断的话，或出现超时和超内存的问题
        if(k>=asc.size()){
            int maxprofit = 0;
            for(int i=0; i<asc.size(); i++){
                maxprofit += (prices[asc[i].second]-prices[asc[i].first]);
            }
            return maxprofit;
        }
        int **profit = new int*[asc.size()+1];  
        for(int i=0; i<=asc.size(); i++)
            profit[i] = new int[k+1];
        
        for(int i=1;i<=k; i++)
            profit[asc.size()-1][i] = prices[asc.rbegin()->second] - prices[asc.rbegin()->first];
        for (int i = 1; i <= k; i++)
			profit[asc.size()][i] = 0 ;
        for(int i=0; i<=asc.size(); i++)
            profit[i][0] = 0;
        for(int i=asc.size()-2; i>=0; i--)
            for(int j=1; j<=k; j++){
                profit[i][j] = profit[i+1][j];
                
                for(int n=i; n<asc.size(); n++){
                    if(prices[asc[n].first]<prices[asc[i].first])
                        break;
                    if(prices[asc[n].second]-prices[asc[i].first]+profit[n+1][j-1] > profit[i][j])
                        profit[i][j] = prices[asc[n].second]-prices[asc[i].first]+profit[n+1][j-1];
                }
                
            }
        return profit[0][k];
    }
    */
    
     //网上说的动态规划,在转换方程那里有点难以理解
     /*
     用local[i][j]表示到达第i天时，最多进行j次交易的局部最优解；用global[i][j]表示到达第i天时，
     最多进行j次的全局最优解。它们二者的关系如下（其中diff = prices[i] – prices[i – 1]）：

        local[i][j] = max(global[i – 1][j – 1] , local[i – 1][j] + diff)
        global[i][j] = max(global[i – 1][j], local[i][j])
        
     local[i][j]和global[i][j]的区别是：local[i][j]意味着在第i天一定有交易（卖出）发生，当第i天的价格
     高于第i-1天（即diff > 0）时，那么可以把这次交易（第i-1天买入第i天卖出）跟第i-1天的交易（卖出）合并
     为一次交易，即local[i][j]=local[i-1][j]+diff；当第i天的价格不高于第i-1天（即diff<=0）时，
     那么local[i][j]=global[i-1][j-1]+diff，而由于diff<=0，所以可写成local[i][j]=global[i-1][j-1]。
     global[i][j]就是我们所求的前i天最多进行k次交易的最大收益，可分为两种情况：如果第i天没有交易（卖出），
     那么global[i][j]=global[i-1][j]；如果第i天有交易（卖出），那么global[i][j]=local[i][j]。
     */
     //8ms
     int maxProfit(int k, vector<int>& prices) {
        if(prices.size() <= 1)
            return 0;
        int days = prices.size();
        //这里要加上这一个判断，不然的会也会超时超内存！！！
        if(k>=days)
            return getMaxProfit(prices);
        int **local = new int*[days];
        int **global = new int*[days];
        
        for(int i=0; i<days; i++){
            local[i] = new int[k+1];
            global[i] = new int[k+1];
        }
        for(int i=0; i<=k; i++){
            local[0][i] = 0;
            global[0][i] = 0;
        }
        for(int i=0; i<days; i++){
            local[i][0] = 0;
            global[i][0] = 0;
        }
        for(int i=1; i<days; i++){
            int diff = prices[i]-prices[i-1];
            
            for(int j=1; j<=k; j++){
                local[i][j] = max(global[i-1][j-1], local[i-1][j]+diff);
                global[i][j] = max(global[i-1][j], local[i][j]);
            }
        }
        return global[days-1][k];
     }
     
     int getMaxProfit(vector<int> &prices){
         int ret = 0;
         for(int i=1; i<prices.size(); i++)
             if(prices[i]>prices[i-1])
                 ret += (prices[i]-prices[i-1]);
        return ret;
     }
}


Dungeon Game 
table.dungeon, .dungeon th, .dungeon td {  border:3px solid black;} .dungeon th, .dungeon td {    text-align: center;    height: 70px;    width: 70px;}The demons had captured the princess (P) and imprisoned her in the bottom-right corner of a dungeon. The dungeon consists of M x N rooms laid out in a 2D grid. Our valiant knight (K) was initially positioned in the top-left room and must fight his way through the dungeon to rescue the princess. The knight has an initial health point represented by a positive integer. If at any point his health point drops to 0 or below, he dies immediately. Some of the rooms are guarded by demons, so the knight loses health (negative integers) upon entering these rooms; other rooms are either empty (0's) or contain magic orbs that increase the knight's health (positive integers).In order to reach the princess as quickly as possible, the knight decides to move only rightward or downward in each step. Write a function to determine the knight's minimum initial health so that he is able to rescue the princess.For example, given the dungeon below, the initial health of the knight must be at least 7 if he follows the optimal path RIGHT->; RIGHT ->; DOWN ->; DOWN. -2 (K) -3 3   -5 -10 1   10 30 -5 (P)  Notes:The knight's health has no upper bound.Any room can contain threats or power-ups, even the first room the knight enters and the bottom-right room where the princess is imprisoned.  
Credits:Special thanks to @stellari for adding this problem and creating all test cases.

class Solution {
public:
    //动态规划算法
    int calculateMinimumHP(vector<vector<int>>& dungeon) {
        int row = dungeon.size();
        int col = dungeon[0].size();
        int **point = new int*[row+1];
        for(int i=0; i<=row; i++){
            point[i] = new int[col+1];
        }
        for(int i=0; i<=row; i++)
            point[i][col] = INT_MAX;
        for(int i=0; i<=col; i++)
            point[row][i] = INT_MAX;
        point[row-1][col-1] = dungeon[row-1][col-1]>=0? 1: 1-dungeon[row-1][col-1];
        for(int i=row-1; i>=0; i--)
            for(int j=col-1; j>=0; j--){
                if(i == row-1 && j == col-1)
                    continue;
                point[i][j] = min(point[i][j+1], point[i+1][j]);
                if(dungeon[i][j]>=0)
                    point[i][j] = point[i][j]-dungeon[i][j]>0? point[i][j]-dungeon[i][j]: 1;
                else
                    point[i][j] = point[i][j]-dungeon[i][j];
                  
        }
        return point[0][0];
    }
}


Maximum Product Subarray 
Find the contiguous subarray within an array (containing at least one number) which has the largest product.For example, given the array [2,3,-2,4],the contiguous subarray [2,3] has the largest product = 6.

class Solution {
public:
    int maxProduct(vector<int>& nums) {
        int n = nums.size();
        if(n ==0 ) return 0;
        else if(n == 1) return nums[0];

        int posMax, negMax, maxim;
        posMax = max(0, nums[0]);
        negMax = min(0, nums[0]);
        maxim = posMax;

        for(int i=1; i<n; i++){
            if(nums[i] > 0){
                posMax = max(1, posMax)*nums[i];
                negMax = negMax*nums[i];
            }
            else if(nums[i] < 0){
                int negTemp = negMax;
                negMax = max(1, posMax)*nums[i];
                posMax = negTemp*nums[i];
            }
            else {
                posMax = 0;
                negMax = 0;
            }
            if(posMax > maxim) maxim = posMax;
        }

        return maxim;
    }
}


Word Break II 
Given a string s and a dictionary of words dict, add spaces in s to construct a sentence where each word is a valid dictionary word.Return all such possible sentences.For example, givens = "catsanddog",dict = ["cat", "cats", "and", "sand", "dog"].A solution is ["cats and dog", "cat sand dog"].

class Solution {
public:
    vector<string> wordBreak(string s, unordered_set<string>& wordDict) {
        if(s.length() == 0)
            return {};
        bool *canbreak = new bool[s.length() + 1];
        memset(canbreak, false, sizeof(bool)*s.length());
        canbreak[s.length()] = true;
        unordered_set<string>::iterator it;
        int maxwordlength = 0;
        for(it=wordDict.begin(); it!=wordDict.end(); it++){
            if(maxwordlength < it->length())
               maxwordlength = it->length();
        }
        /*
        //这个方法理论上是可行的，只不过在最开始存储所有可能的解到最后有可能s是不可以break的，这样的话，前面的所有存储就白费了
        //不仅浪费很多的空间而且还有很多的时间
        //对于这例子：baaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa   [a, aa, aaa, aaaa, aaaaa]
        //程序在计算可行解的时候会花很长的时间，因为有很多种解法，但其实字符串s不是可以
        //break的。
        
        for(int i=s.length()-1; i>=0; i--){
            for(int j=i; j<s.length() && j<maxwordlength+i; j++){
                string word = s.substr(i, j-i+1);
                if(wordDict.count(word) != 0){
                    vector<string> pre = ret[j+1];
                    for(int k=0; k<pre.size(); k++){
                        ret[i].push_back(word+" "+pre[k]);
                    }
                }
            }
        }
        */
        
        //先计算s是不是可以break的，可以的话，再来计所有的可行解
         for(int i=s.length()-1; i>=0; i--){
            for(int j=i; j<s.length() && j<maxwordlength+i; j++){
                string word = s.substr(i, j-i+1);
                if(wordDict.count(word) != 0){
                    if(canbreak[j+1]){
                        canbreak[i] = true;
                        break;
                    }
                }
            }
        }
        if(!canbreak[0])
            return {};
        //计算所有的可行解
        return getSolution(s, 0, wordDict, canbreak, maxwordlength);
    }
    
   vector<string> getSolution(string s, int start, unordered_set<string>& wordDict, bool *canbreak, int maxwordlength) {
		if (start >= s.length())
			return{};
		vector<string> ret;
		for (int i = start; i < s.length() && i < start+maxwordlength; i++) {
			string word = s.substr(start, i-start+1);
			if (wordDict.count(word) != 0) {
				if (canbreak[i+1]) {
					vector<string> temp = getSolution(s, i+1, wordDict, canbreak, maxwordlength);
					if (temp.size() != 0) {
						for (int j = 0; j<temp.size(); j++) {
							ret.push_back(word + " " + temp[j]);
						}
					}
					else {
						ret.push_back(word);
					}
				}
			}
		}
		return ret;
	}
}


Palindrome Partitioning II 
Given a string s, partition s such that every substring of the partition is a palindrome.Return the minimum cuts needed for a palindrome partitioning of s.For example, given s = "aab",Return 1 since the palindrome partitioning ["aa","b"] could be produced using 1 cut.

class Solution {
public:
    /*
        采用动态规划的方法，不过要先计算每一个s[i:j]是否为回文，先将该值存储在一个bool数组里面
        //状态转换方程：cut[i:j] = (i<= k <=j, 使得s[i:k]是回文且cut[k+1:j]值最小) + 1
        
        如果没有使用数组来存储是否为回文的话，会出现超时！！！
    */

    int minCut(string s) {
        if(s.size() == 0)
            return 0;
        int *cut = new int[s.size()];
        //数组p存储s[i:j]是否为回文
        vector<vector<bool>> p(s.length(), vector<bool>(s.length(), false));
        for(int i=s.length()-1; i>=0; i--)
            for(int j=i; j<s.length(); j++){
                p[i][j] = (i==j)? true: ((j-i==1)?(s[i] == s[j]): p[i+1][j-1] && s[i] == s[j]);
            }
        cut[s.size()-1] = 0;
        for(int i=s.size()-2; i>=0; i--){
            int mincut = INT_MAX;
            if(p[i][s.size()-1]){
                mincut = 0;
            }
            else{
                for(int j=i; j<s.size()-1; j++){
                    if(p[i][j]){
                        if(mincut > 1+cut[j+1]){
                            mincut = 1+cut[j+1];
                            if(mincut == 1)
                                break;
                        }
                    }
                }
            }
            cut[i] = mincut;
            
        }
        return cut[0];
    }

    /*
    bool isPalindrom(string &s, int start, int end){
        for(int i=start, j=end; i<j; i++, j--){
            if(s[i] != s[j])
                return false;
        }
        return true;
    }
    */
}


Best Time to Buy and Sell Stock III 
Say you have an array for which the ith element is the price of a given stock on day i.Design an algorithm to find the maximum profit. You may complete at most two transactions.
Note:You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).

class Solution {
public:
    int maxProfit(vector<int>& prices) {
        if(prices.size() == 0)
            return 0;
        int *left = new int[prices.size()];
        int *right = new int[prices.size()];
        left[0] = 0;
        right[prices.size()-1] = 0;
        int smallest = prices[0];
        for(int i=1; i<prices.size(); i++){
            if(smallest>prices[i])
                smallest = prices[i];
            left[i] = prices[i]-smallest;
            if(left[i]<left[i-1])
                left[i] = left[i-1];
                
        }
        int largest = prices[prices.size()-1];
        for(int i=prices.size()-2; i>=0; i--){
            if(largest<prices[i])
                largest = prices[i];
            right[i] = largest-prices[i];
            if(right[i]<right[i+1])
                 right[i] = right[i+1];
        }
        int ret = INT_MIN;
        for(int i=0; i<prices.size(); i++){
            int temp = left[i]+right[i];
            if(ret<temp)
                ret = temp;
        }
        return ret;
    }
}


Best Time to Buy and Sell Stock 
Say you have an array for which the ith element is the price of a given stock on day i.If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit.

class Solution {
public:
    int maxProfit(vector<int>& prices) {
        if(prices.size() == 0)
            return 0;
        int profit = 0;
        int smallest = prices[0];
        for(int i=1; i<prices.size(); i++){
            if(profit<prices[i]-smallest)
                profit = prices[i]-smallest;
            if(smallest>prices[i])
                smallest = prices[i];
        }
    return profit;
    }
}


Triangle 
Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below.For example, given the following triangle[     [2],    [3,4],   [6,5,7],  [4,1,8,3]]The minimum path sum from top to bottom is 11 (i.e., 2 + 3 + 5 + 1 = 11).
Note:Bonus point if you are able to do this using only O(n) extra space, where n is the total number of rows in the triangle.

class Solution {
public:  
    //直接的采用深度搜索会超时，这里跟树的遍历不一样，因为每一个节点只能遍历到其下一层的邻居节点，
    //也就是说同一层的相邻节点有一个共同的下层子节点，这也就是该问题的关键所在，可以根据该特点来
    //减少相同的遍历，从而提高速度。
    /*
    int minimumTotal(vector<vector<int>>& triangle) {
        if(triangle.size() == 0)
            return 0;
       
        int min = INT_MAX;
        minimumTotal(triangle, 1, 0, triangle[0][0], min);
        return min;
    }
    
    void minimumTotal(vector<vector<int> > &triangle, int row, int start, int sum, int &min){
        if(row == triangle.size()){
             if(min>sum)
               min = sum;
        }
        else{
            for(int i=start; i<=start+1; i++){
                minimumTotal(triangle, row+1, i, sum+triangle[row][i], min);
            }
        }
    }
    */
    //采用动态规划的方法
    int minimumTotal(vector<vector<int>>& triangle) {
        if(triangle.size() == 0)
            return 0;
       
        int *min = new int[triangle.size()];
        for(int i=0; i<triangle.size(); i++)
            min[i] = triangle[triangle.size()-1][i];
        for(int i=triangle.size()-2; i>=0; i--){
            int temp = min[i+1];
            for(int j=i; j>=0; j--){
                int val = triangle[i][j]+(temp>min[j]? min[j]:temp);
                temp = min[j];
                min[j] = val;
            }
               
        }
        return min[0];
    }
}


Distinct Subsequences 
Given a string S and a string T, count the number of distinct subsequences of T in S.A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, "ACE" is a subsequence of "ABCDE" while "AEC" is not).Here is an example:S = "rabbbit", T = "rabbit"Return 3.

class Solution {
public:
    //动态规划的方法，length[i][j] = :
    //if(t[i] == s[j]) then length[i-1][j-1]+length[i][j-1]
    //else  then length[i-1][j-1];
    int numDistinct(string s, string t) {
        if(t.length() == 0)
            return 1;
        if(s.length() == 0)
            return 0;
        int row = t.size();
        int col = s.length();
        int **length = new int*[row+1];
        
        for (int i = 0; i <= row; i++)
			length[i] = new int[col + 1];
		//当S为空时，所有值为0
		for (int i = 0; i <= row; i++)
			length[i][0] = 0;
		//当t为空时，所有值为1， 这个循环必须在上一个循环的下面，因为要确保length[0][0] = 1;
		for (int i = 0; i <= col; i++)
			length[0][i] = 1;
		//length的下标是长度，所以要+1
        for(int i=0; i<row; i++)    //遍历T
            for(int j=0; j<col; j++){    //遍历S
                if(t[i] != s[j])
                    length[i+1][j+1] = length[i+1][j];
                else
                    length[i+1][j+1] = length[i+1][j] + length[i][j];
                    
            }
        return length[row][col];
    }
}


Interleaving String 
Given s1, s2, s3, find whether s3 is formed by the interleaving of s1 and s2.For example,Given:s1 = "aabcc",s2 = "dbbca",When s3 = "aadbbcbcac", return true.When s3 = "aadbbbaccc", return false.

class Solution {
public:
    bool isInterleave(string s1, string s2, string s3) {
        if(s3.length() != (s1.length()+s2.length()))
            return false;
        bool **caninterleave = new bool*[s1.length()+1];
        for(int i=0; i<=s1.length(); i++)
            caninterleave[i] = new bool[s2.length()+1];
            
        for(int i=0; i<s1.length(); i++){
            caninterleave[i+1][0] = (s1.substr(0, i+1)==s3.substr(0, i+1));
        }
        for(int i=0; i<s2.length(); i++)
            caninterleave[0][i+1] = (s2.substr(0, i+1)==s3.substr(0, i+1));
        caninterleave[0][0] = true;
        
        for(int i=0; i<s1.length(); i++)
            for(int j=0; j<s2.length(); j++){
                if(s3[i+j+1] != s1[i] && s3[i+j+1] != s2[j])
                    caninterleave[i+1][j+1] = false;
                else{
                    if(s3[i+j+1] == s1[i] && s3[i+j+1] == s2[j])
                        caninterleave[i+1][j+1] = (caninterleave[i][j+1] || caninterleave[i+1][j]);
                    else if(s3[i+j+1] == s1[i])
                        caninterleave[i+1][j+1] = caninterleave[i][j+1];
                    else 
                        caninterleave[i+1][j+1] = caninterleave[i+1][j];
                }
            }
        return caninterleave[s1.length()][s2.length()];
    }
}


Unique Binary Search Trees II 
Given n, generate all structurally unique BST's (binary search trees) that store values 1...n.For example,Given n = 3, your program should return all 5 unique BST's shown below.   1         3     3      2      1    \       /     /      / \      \     3     2     1      1   3      2    /     /       \                 \   2     1         2                 3confused what "{1,#,2,3}" means? >; read more on how binary tree is serialized on OJ.OJ's Binary Tree Serialization:The serialization of a binary tree follows a level order traversal, where '#' signifies a path terminator where no node exists below.Here's an example:   1  / \ 2   3    /   4    \     5The above binary tree is serialized as "{1,2,3,#,#,4,#,#,5}". 

/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector<TreeNode*> generateTrees(int n) {
        vector<TreeNode*> ret;
        if(n == 0){
            ret.push_back(NULL);
            return ret;
        }
            
        
        return generateTrees(1, n);
    }
    
    vector<TreeNode*> generateTrees(int start, int end){
        vector<TreeNode*> ret;
        if(start > end)
            return ret;
        if(start == end){
            TreeNode *node = new TreeNode(start);
            ret.push_back(node);
            return ret;
        }
        for(int i=start; i<=end; i++){
            vector<TreeNode*> left = generateTrees(start, i-1);
            vector<TreeNode*> right = generateTrees(i+1, end);
            if(left.size() == 0 && right.size() == 0){
                TreeNode* root = new TreeNode(i);
                ret.push_back(root);
                continue;
            }
            if(left.size() == 0){
                for(int j=0; j<right.size(); j++){
                    TreeNode* root = new TreeNode(i);
                    root->right = right[j];
                    ret.push_back(root);
                }
                continue;
            }
            if(right.size() == 0){
                for(int j=0; j<left.size(); j++){
                    TreeNode* root = new TreeNode(i);
                    root->left = left[j];
                    ret.push_back(root);
                }
                continue;
            }
            for(int k=0; k<left.size(); k++){
                for(int j=0; j<right.size(); j++){
                    TreeNode *root = new TreeNode(i);
                    root->left = left[k];
                    root->right = right[j];
                    ret.push_back(root);
                }
            }  
        }
        
        return ret;
    }
}


Unique Binary Search Trees 
Given n, how many structurally unique BST's (binary search trees) that store values 1...n?For example,Given n = 3, there are a total of 5 unique BST's.   1         3     3      2      1    \       /     /      / \      \     3     2     1      1   3      2    /     /       \                 \   2     1         2                 3

class Solution {
public:
    //简单的采用递归会超时！！！！
    /*
    int numTrees(int n) {
        if(n == 1)
            return 1;
        return numTrees(1, n);
    }
    
    int numTrees(int start, int end){
        if(start > end)
            return 0;
        if(start == end)
            return 1;
        int total = 0;
        for(int i=start; i<=end; i++){
            int left = numTrees(start, i-1);
            int right = numTrees(i+1, end);
            if(left == 0 || right == 0)
                total += (left+right);
            else
                total += (left*right);
            
        }
        return total;
    }
    */
    //另一种更加简单的递归,仍然超时！！！
    /*
    int numTrees(int n) {
        if(n <= 1)
            return n;
        int total = 0;
        for(int i=0; i<n; i++){
            int left = numTrees(i);
            int right = numTrees(n-i-1);
            if(left == 0 || right == 0)
                total += (left+right);
            else
                total += (left*right);
        }
        return total;
    }
    */
    
    //加备忘录
    
     int numTrees(int n) {
        if(n <= 1)
            return n;
        int *f = new int[n+1];
        f[0] = 0;
        f[1] = 1;
        for(int i=2; i<=n; i++)
            f[i] = -1;
        numTrees(n, f);
        return f[n];
    }
    void numTrees(int n, int *f){
        if(n < 0)
            return;
        if(f[n] != -1)
            return ;
        f[n] = 0;
        for(int i=1; i<=n; i++){
            if(f[i-1] == -1)
                numTrees(i-1, f);
            if(f[n-i] == -1)
                numTrees(n-i, f);
            if(f[i-1] == 0 || f[n-i] == 0)
                f[n] += f[i-1]+f[n-i];
            else
                f[n] += f[i-1]*f[n-i];
        }
    }
    
    
   
}


Decode Ways 
A message containing letters from A-Z is being encoded to numbers using the following mapping:'A' ->; 1'B' ->; 2...'Z' ->; 26Given an encoded message containing digits, determine the total number of ways to decode it.For example,Given encoded message "12",it could be decoded as "AB" (1 2) or "L" (12).The number of ways decoding "12" is 2.

class Solution {
public:
    //递归、递归加备忘录、动态规划三种都可以
    //采用动态规划的方法
    //思路：从右到左遍历，如果s[i]可以和s[i+1]组合，那么从i到最后面的子窜的可能编码数量为f[i+1]+f[i+2]
    //否则的话f[i] = f[i+1];
    //因为只涉及到i的前面两个数，所以可以不用申请数组，直接申明两个变量来记录前面的两个值就好了！！！
    //麻烦的就是0的出现，因为可以解码的情况只有10和20，其他情况下0的出现都会导致不能解码，结果为0。
    int numDecodings(string s) {
        if(s.size() == 0 || s[0] == '0')
            return 0;
        int cur = 1;
        int firstpre = 1;
        int secondpre = 1;
        int i = 0;
        if(s[s.size()-1] == '0'){
            if(s[s.size()-2] == '2' || s[s.size()-2] == '1')
                i = s.size()-3;
            else
                return 0;
        }
        else{
            s = s+'_';
            i = s.size()-3;
        }
            
        for(; i>=0; i--){
            if(s[i] == '0' ){
                if(s[i-1] == '1' || s[i-1] == '2'){
                    cur = firstpre;
                    secondpre = firstpre;
                    firstpre = cur;
                    i--;
                }
                else
                    return 0;
            }
            else if(s[i]>='3' || (s[i] == '2' && s[i+1] > '6') || s[i+2] == '0'){
                cur = firstpre;
                secondpre = firstpre;
                firstpre = cur;
            }
            else{
                cur = firstpre + secondpre;
                secondpre = firstpre;
                firstpre = cur;
            }
        }
        return cur;
    }
}


Scramble String 
Given a string s1, we may represent it as a binary tree by partitioning it to two non-empty substrings recursively.Below is one possible representation of s1 = "great":    great   /    \  gr    eat / \    /  \g   r  e   at           / \          a   tTo scramble the string, we may choose any non-leaf node and swap its two children.For example, if we choose the node "gr" and swap its two children, it produces a scrambled string "rgeat".    rgeat   /    \  rg    eat / \    /  \r   g  e   at           / \          a   tWe say that "rgeat" is a scrambled string of "great".Similarly, if we continue to swap the children of nodes "eat" and "at", it produces a scrambled string "rgtae".    rgtae   /    \  rg    tae / \    /  \r   g  ta  e       / \      t   aWe say that "rgtae" is a scrambled string of "great".Given two strings s1 and s2 of the same length, determine if s2 is a scrambled string of s1.

class Solution {
public:
    //采用递归的方式, 最直接的思路就是将s1分成两部分s1l, s1r, 将s2也分成s2l, s2r，以及s2ll、s2rr
    //s2ll为从s2的右边开始按照s1l的长度分割出来的子串，剩下的作为s2rr，然后循环判断：
    //(isScramble(s1l, s2l)&&isScramble(s1r, s2r)) || (isScramble(s1l, s2rr)&&isScramble(s1r, s2ll))
    //16ms
    /*
    bool isScramble(string s1, string s2) {
        if(s1.length() != s1.length())
            return false;
        if(s1 == s2)
            return true;
        string temps1 = s1;
        string temps2 = s2;
        //先排序，看看s1和s2里面的字符是否都是一样的，否则的话，直接返回false，减少循环
        sort(temps1.begin(), temps1.end());
        sort(temps2.begin(), temps2.end());
        if(temps1 != temps2)
            return false;
        bool ret = false;
        for(int i=1; i<s1.length(); i++){
            string s1l = s1.substr(0, i);
            string s1r = s1.substr(i, s1.length()-i);
            
            string s2l = s2.substr(0, i);
            string s2r = s2.substr(i, s2.length()-i);
            
            string s2ll = s2.substr(0, s2.length()-i);
            string s2rr = s2.substr(s2.length()-i, i);
            
            ret = (isScramble(s1l, s2l)&&isScramble(s1r, s2r)) || (isScramble(s1l, s2rr)&&isScramble(s1r, s2ll));
            //只要又一次是true，就说明s1和s2可以匹配
            if(ret)
                return true;
        }
        //找不到的情况下返回false
        return false;
    }
    */
    //采用动态规划的方法 reslut[k][i][j]表示长度为k的子串，s1以i开始，s2以j开始，能不能匹配的到，能匹配的条件
    //跟循环的条件是一样的
    //16ms
    bool isScramble(string s1, string s2) {
        if(s1.length() != s1.length())
            return false;
        if(s1 == s2)
            return true;
        int len = s1.size() + 1;    
        bool*** result = new bool**[len];
        for(int i=0; i<len; i++)
            result[i] = new bool*[len];
        for(int i=0; i<len; i++)
            for(int j=0; j<len; j++)
                result[i][j] = new bool[len];
        for(int i=s1.length()-1; i>=0; i--)
            for(int j=s2.length(); j>=0; j--){
                result[1][i][j] = (s1[i] == s2[j]);
            }
        for(int k=2; k<=s1.length(); k++)
            for(int i=s1.length()-k; i>=0; i--)
                for(int j=s2.length()-k; j>=0; j--){
                    bool r = false;
                    //将长度为k的子串进行分割，看看每一部分是否可以匹配，只要有一种分割的的方法可以匹配，就说名匹配成功
                    for(int m=1; m<k; m++)
                        if(result[m][i][j]&&result[k-m][i+m][j+m] || result[m][i][j+k-m]&&result[k-m][i+m][j]){
                            r = true;
                            break;
                        }
                    result[k][i][j] = r;    
                }
        return result[s1.length()][0][0];
    }
}


Maximal Rectangle 
Given a 2D binary matrix filled with 0's and 1's, find the largest rectangle containing all ones and return its area.

class Solution {
public:
    /*
    //直接的以每一个元素作为长方形的左上角，以改点作为起始点，计算长方形的最大的面积
    //92ms
    int maximalRectangle(vector<vector<char>>& matrix) {
        if(matrix.size() == 0 || matrix[0].size() == 0)
            return 0;
        int largestarea = 0;
        int row = matrix.size();
        int col = matrix[0].size();
        for(int i=0; i<row; i++)
            for(int j=0; j<col; j++){
                int wide = INT_MAX;
                int starti = i;
                int area = 0;
                //计算以i，j为左上角的长方形的面积
                while(starti<row&&matrix[starti][j] == '1'){
                    int index = j;
                    while(index<col && matrix[starti][index]=='1')
                       index++;
                    if(wide>index-j)
                        wide = index-j;
                    starti++;
                    if(area<(starti-i)*wide)
                        area = (starti-i)*wide;
                }
                if(largestarea<area)
                    largestarea = area;
                
            }
         return largestarea;    
    }
    */
    
    //利用动态规划的思想，以及Largest Rectangle in Histogram的阶梯思路(需要O(N)空间以及O(N)的时间)
    //将矩阵每一行作为底，那么当前行上面的所有连续的为1的元素看成是一条柱形，直接的求每一行的最大长方形面积
    //就可以了,时间复杂度为O(M*N),空间也一样,不过空间还是可以在减少到O(N)的
    //28ms
    int maximalRectangle(vector<vector<char>>& matrix) {
        if(matrix.size() == 0 || matrix[0].size() == 0)
            return 0;
        int row = matrix.size();
		int col = matrix[0].size();
		int ret = 0;
		//记录每一行的连续的1的高度， 这里利用一点动态规划的思想
		vector<vector<int>> dp(row, vector<int>(col));
		//计算出以每一行为底部的柱形的高度
        for(int i=0; i<col; i++)
            dp[0][i] = matrix[0][i]=='1'? 1: 0;
        for(int i=1; i<row; i++){
            for(int j=0; j<col; j++){
                if(matrix[i][j] == '0')
                    dp[i][j] = 0;
                else
                    dp[i][j] = dp[i-1][j]+1;
            }
        }
        for(int i=0; i<row; i++){
            int area = getTheLargestRetangle(dp[i]);
            if(ret<area)
                ret = area;
        }
        return ret;
    }
    
    int getTheLargestRetangle(vector<int> &height){
        if(height.size() == 0)
            return 0;
        stack<int> stk;
        int maxarea = 0;
        int area = 0;
        for(int i=0; i<height.size(); i++){
            while(!stk.empty() && height[stk.top()]>height[i]){
                int index = stk.top();
                stk.pop();
                area = stk.empty()? i*height[index]: (i-stk.top()-1)*height[index];
                if(maxarea<area)
                    maxarea = area;
            }
            stk.push(i);
        }
       
        while(!stk.empty()){
            int index = stk.top();
            stk.pop();
            area = stk.empty()? height.size()*height[index]: (height.size()-stk.top()-1)*height[index];
            if(maxarea<area)
                maxarea = area;
        }
        
        return maxarea;
    }
    
}


Edit Distance 
Given two words word1 and word2, find the minimum number of steps required to convert word1 to word2. (each operation is counted as 1 step.)You have the following 3 operations permitted on a word:a) Insert a characterb) Delete a characterc) Replace a character

class Solution {
public:
    /*
    //按照字面的理解所得出的算法
    int minDistance(string word1, string word2) {
        if(word1.size() == 0)
            return word2.size();
        if(word2.size() == 0)
            return word1.size();
        int **f = new int*[word1.size()+1];
        for(int i=0; i<=word1.size(); i++){
            f[i] = new int[word2.size()+1];
        }
        for(int i=0; i<=word2.size(); i++)
            f[0][i] = i;
        for(int i=0; i<=word1.size(); i++)
            f[i][0] = i;
        for(int i=1; i<=word1.size(); i++)
            for(int j=1; j<=word2.size(); j++){
                if(word1[i-1] == word2[j-1]){
                    f[i][j] = f[i-1][j-1]>(f[i-1][j]+1)? (f[i-1][j]+1): f[i-1][j-1];
                    f[i][j] = f[i][j]>(f[i][j-1]+1)? (f[i][j-1]+1): f[i][j];
                }
                else{
                    f[i][j] = (f[i-1][j-1]+1)>(f[i-1][j]+1)? (f[i-1][j]+1): (f[i-1][j-1]+1);
                    f[i][j] = f[i][j]>(f[i][j-1]+1)? (f[i][j-1]+1): f[i][j];
                }
                    
            }
        return f[word1.size()][word2.size()];
                
    }
    */
    /*
    1. f[0, j] = j;
    2. f[i, 0] = i;
    3. f[i, j] = f[i-1, j - 1] if A[i] == B[j]
    4. f[i, j] = min(f[i-1, j - 1], f[i, j - 1], f[i-1, j]) + 1  if A[i] != B[j]
    */
    int minDistance(string word1, string word2) {
        if(word1.size() == 0)
            return word2.size();
        if(word2.size() == 0)
            return word1.size();
        int **f = new int*[word1.size()+1];
        for(int i=0; i<=word1.size(); i++){
            f[i] = new int[word2.size()+1];
        }
        for(int i=0; i<=word2.size(); i++)
            f[0][i] = i;
        for(int i=0; i<=word1.size(); i++)
            f[i][0] = i;
        for(int i=1; i<=word1.size(); i++)
            for(int j=1; j<=word2.size(); j++){
                if(word1[i-1] == word2[j-1]){
                    f[i][j] = f[i-1][j-1];
                    //f[i][j] = f[i][j]>(f[i][j-1]+1)? (f[i][j-1]+1): f[i][j];
                }
                else{
                    f[i][j] = (f[i-1][j-1]+1)>(f[i-1][j]+1)? (f[i-1][j]+1): (f[i-1][j-1]+1);
                    f[i][j] = f[i][j]>(f[i][j-1]+1)? (f[i][j-1]+1): f[i][j];
                }
                    
            }
        return f[word1.size()][word2.size()];
                
    }
}


Climbing Stairs 
You are climbing a stair case. It takes n steps to reach to the top.Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?

class Solution {
public:
    //递归，要到达顶部，最后的一步有两种方法，第一种为爬一步，第二中为爬两步
    //超时！超时！超时！
    /*
    int climbStairs(int n) {
        if(n <= 1)
            return 1;
        return climbStairs(n-1) + climbStairs(n-2);
    }
    */
    //备忘录的方法
    //内存溢出！！！！！
    /*
    int climbStairs(int n) {
        int *p = new int[n+1];
        for(int i=0; i<n; i++)
            p[i] = 0;
        _climbStairs(n, p);
        return p[n];
    }
    
    int _climbStairs(int n, int *p) {
        if(n <= 1)
            return p[n] = 1;
        if(p[n-1] == 0)
            p[n-1] = climbStairs(n-1);
        if(p[n-2] == 0)
            p[n-2] = climbStairs(n-2);
        p[n] = p[n-1]+p[n-2];
    }
    */
    
    //采用动态规划的方法，这里不能在声明一个数组了，否则又会内存溢出。
    int climbStairs(int n) {
        if(n<=1)
            return 1;
        int n_1 = 1;
        int n_2 = 1;
        int temp = 0;
        for(int i=2; i<n; i++){
            temp =n_1 + n_2;
            n_2 = n_1;
            n_1 = temp;
        }
        return n_1+n_2;  
    }
    
}


Minimum Path Sum 
Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path.
Note: You can only move either down or right at any point in time.

class Solution {
public:

    //递归会超时！！！
    /*
    int minPathSum(vector<vector<int>>& grid) {
        if(grid.size() == 0)
            return 0;
        return _minPathSum(grid, 0, 0);
    }
    int _minPathSum(vector<vector<int>>& grid, int i, int j){
        if(i== grid.size() || j == grid[0].size())
            return INT_MAX;
        if(i== grid.size()-1 && j == grid[0].size()-1)
            return grid[i][j];
        int down  = _minPathSum(grid, i+1, j);
        int right = _minPathSum(grid, i, j+1);
        return down<right? grid[i][j]+down: grid[i][j]+right;
    }
    */
    
    
    //加备忘录
    /*
    int minPathSum(vector<vector<int>>& grid) {
        if(grid.size() == 0)
            return 0;
        int row = grid.size();
        int col = grid[0].size();
        int **f = new int*[row+1];
        for(int i=0; i<=row; i++)
            f[i] = new int[col+1];
        for(int i=0; i<=row; i++)
            for(int j=0; j<=col; j++)
                f[i][j] = -1;
        return _minPathSum(grid, 0, 0, f);
    }
    
    int _minPathSum(vector<vector<int>>& grid, int i, int j, int **f){
        if(i== grid.size() || j == grid[0].size())
            return INT_MAX;
        if(i== grid.size()-1 && j == grid[0].size()-1)
            return grid[i][j];
        
        int down;
        if(f[i+1][j] == -1){
            down = _minPathSum(grid, i+1, j, f);
            f[i+1][j] = down;
        }
        else
            down = f[i+1][j];
            
        int right;
        if(f[i][j+1] == -1){
            right = _minPathSum(grid, i, j+1, f);
            f[i][j+1] = right;
        }
        else
            right = f[i][j+1];
        
        return down<right? grid[i][j]+down: grid[i][j]+right;
    }
    */
    
    //动态规划+滚动数组
    int minPathSum(vector<vector<int>>& grid) {
        if(grid.size() == 0)
            return 0;
        int row = grid.size();
        int col = grid[0].size();
        int *f = new int[col];
        for(int i=0; i<col-1; i++)
            f[i] = INT_MAX;
        f[col-1] = 0;
        for(int i=row-1; i>=0; i--)
            for(int j=col-1; j>=0; j--){
                if(j == col-1)
                    f[j] += grid[i][j];
                else{
                    f[j] = f[j]>f[j+1]? f[j+1]+grid[i][j]: grid[i][j]+f[j];
                }
            }
        return f[0];     
        
    }
}


Unique Paths II 
Follow up for "Unique Paths":Now consider if some obstacles are added to the grids. How many unique paths would there be?An obstacle and empty space is marked as 1 and 0 respectively in the grid.For example,There is one obstacle in the middle of a 3x3 grid as illustrated below.[  [0,0,0],  [0,1,0],  [0,0,0]]The total number of unique paths is 2.
Note: m and n will be at most 100.

class Solution {
public:
    //直接的动态+滚动数组
    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
        if(obstacleGrid.size() == 0)
            return 0;
        int m = obstacleGrid.size();
        int n = obstacleGrid[0].size();
        int *f = new int[n+1];
        
        for(int i=n; i>=0; i--)
            f[i] = 0;
        f[n-1] = obstacleGrid[m-1][n-1] == 1? 0: 1;
        for(int i=m-1; i>=0; i--)
            for(int j=n-1; j>=0; j--){
                if(i == m-1 && j == n-1)
                    continue;
                if(obstacleGrid[i][j] == 1)
                    f[j] = 0;
                else{
                    f[j] = f[j] + f[j+1];
                }
            }
        return f[0];
    }
}


Unique Paths 
A robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below).The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below).How many possible unique paths are there?Above is a 3 x 7 grid. How many possible unique paths are there?
Note: m and n will be at most 100.

class Solution {
public:
    //可以直接的使用排列组合的公式：C(m-1, m-1+n-1)来计算结果的数量，但是m和n的值有可能是100， 结果会出现溢出，所以
    //还是不能直接的使用数学公式
    //直接的递归会超时！！！
    //加备忘录
    /*
    int uniquePaths(int m, int n) {
        if(m == 1 || n == 1)
            return 1;
        int **f = new int*[m];
        for(int i=0; i<m; i++)
            f[i] = new int[n];
        for(int i=0; i<m; i++)
            for(int j=0; j<n; j++)
                f[i][j] = -1;
        for(int i=0; i<n; i++)
            f[m-1][i] = 1;
        for(int i=0; i<m; i++)
            f[i][n-1] = 1;
            
        _uniquePath(m, n, 0, 0, f);
        return f[0][0];
    }
    
    void _uniquePath(int m, int n, int startrow, int startcol, int **f){
        if(f[startrow][startcol] != -1)
            return ;
        if(f[startrow][startcol+1] == -1)
           _uniquePath(m, n, startrow, startcol+1, f);
        if(f[startrow+1][startcol] == -1)
           _uniquePath(m, n, startrow+1, startcol, f);
        f[startrow][startcol] = f[startrow][startcol+1]+f[startrow+1][startcol];
            
    }
    */
    
    //使用动态规划+滚动数组
    int uniquePaths(int m, int n) {
        if(m == 1 || n == 1)
            return 1;
        int *f = new int[n];
        for(int i=0; i<n; i++)
            f[i] = 1;
        for(int i=0; i<m-1; i++)
            for(int j=n-2; j>=0; j--)
                f[j] = f[j] + f[j+1];
        return f[0];

    }
}


Maximum Subarray 
Find the contiguous subarray within an array (containing at least one number) which has the largest sum.For example, given the array [&amp;#8722;2,1,&amp;#8722;3,4,&amp;#8722;1,2,1,&amp;#8722;5,4],the contiguous subarray [4,&amp;#8722;1,2,1] has the largest sum = 6.click to show more practice.More practice:If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.

class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        if(nums.size() == 0)
            return 0;
        int largest = INT_MIN;
        int pre = -1;
        for(int i=0; i<nums.size(); i++){
            if(pre>0){
                pre += nums[i];
               
            }
            else{
                pre = nums[i];
            }
            if(largest<pre)
                largest = pre;
        }
        return largest;
    }
}


Wildcard Matching 
Implement wildcard pattern matching with support for '?' and '*'.'?' Matches any single character.'*' Matches any sequence of characters (including the empty sequence).The matching should cover the entire input string (not partial).The function prototype should be:bool isMatch(const char *s, const char *p)Some examples:isMatch("aa","a") → falseisMatch("aa","aa") → trueisMatch("aaa","aa") → falseisMatch("aa", "*") → trueisMatch("aa", "a*") → trueisMatch("ab", "?*") → trueisMatch("aab", "c*a*b") → false

class Solution {
public:
    //动态规划f[i][j]存储p[i:-1]能否匹配s[j:-1]
    //状态转换方程：
    //if(p[i] = [a-z]) f[i][j] = p[i]==s[j]&&f[i+1][j+1]
    //if(p[i] == '?') f[i][j] = f[i+1][j+1]
    //if(p[i] == '*') for(j<=k<=s.length) if(f[i+1][k]) f[i+1][j] = true
    bool isMatch(string s, string p) {
        if(s.length()==0 && p.length()==0)
            return true;
        if(p.length() == 0)
            return false;
        bool **f = new bool*[p.length()+1];
        for(int i=0; i<=p.length(); i++)
            f[i] = new bool[s.length()+1];
        for(int i=0; i<p.length(); i++)
            f[i][s.length()] = false;
        for(int i=0; i<s.length(); i++)
            f[p.length()][i] = false;
        f[p.length()][s.length()] = true;
        //处理p='****', s=""类型的情况
        int length = p.length()-1;
        while(p[length] == '*'){
            f[length][s.length()] = true;
            length--;
        }
        for(int i=p.length()-1; i>=0; i--){
            for(int j=s.length()-1; j>=0; j--){
                if(p[i] == '?')
                    f[i][j] = f[i+1][j+1];
                else if('a'<=p[i] && p[i]<='z')
                    f[i][j] = p[i]==s[j]&&f[i+1][j+1];
                else{
                    f[i][j] = false;
                    for(int k=j; k<=s.length(); k++){
                        if(f[i+1][k]){
                            f[i][j] = true;
                            break;
                        }
                    }
                    
                }
            }
        }
        return f[0][0];
    }
}


Longest Valid Parentheses 
Given a string containing just the characters '(' and ')', find the length of the longest valid (well-formed) parentheses substring.For "(()", the longest valid parentheses substring is "()", which has length = 2.Another example is ")()())", where the longest valid parentheses substring is "()()", which has length = 4.

class Solution {
public:
    //从左到右遍历字符串，遍历过程中只标记左括号的数量left、上一个可匹配的字段的长度，以及其结束的下标，如果遍历的过程中
    //left==0 那么说明已经匹配到一个子段了，此时要看看该子段能否与上一个匹配的子段合并，可以的话合并成更长的子段。不行的话
    //更新prelength和preend，继续遍历
    int longestValidParentheses(string s) {
        if(s.size() == 0)
            return 0;
        int longest = 0;
        //左括号的数量
        int left = 0;
        //当前的长度
        int curlength = 0;
        //上一个可匹配的子段的长度
        int prelength = 0;
        //上一个可匹配的子段的结束下标
        int preend = -1;
        int start = 0;
        //忽略字符串s的头部不合法的右括号
        while(start<s.size() && s[start] == ')')start++;
        int end = s.size()-1;
        //忽略字符串s尾部不合法的左括号
        while(end>=0 && s[end] == '(')end--;
        if(end < start)
            return 0;
        for(int i=start; i<=end; i++){
            if(left == 0 && s[i] == ')')
                continue;
            if(s[i] == '('){
                left++;
                continue;
            }
            if(s[i] == ')'){
                curlength++;
                left--;
                //完成了新的一小段的匹配，要看看是否可以跟上一个匹配拼接在一起，可以的话，
                //要拼接在一起，构成更长的一段
                if(left == 0){
                    if(i-curlength*2 == preend)
                        prelength = prelength + curlength;
                    else
                        prelength = curlength;
                    preend = i;
                    if(longest<prelength)
                        longest = prelength;
                    curlength = 0;
                }
            }
        }
        //如果左括号的数量为0，说明最后的curlength是一个合法的子段
        if(left == 0){
            if(curlength > longest)
                longest = curlength;
            return longest*2;
        }
        //left不为0，说明当前的到的curlength所代表的子段不是合法的，此时最简单的方法就是将当前的子段
        //翻转过来，对翻转后的子段进行重新的匹配计算
        //例子：(()(((((()
        else{
            string reverse = "";
            //这里不能简单的直接翻转，还要进行括号的左->右 和 右->左变换
            for (int i = s.size() - 1; i > preend; i--) {
				if (s[i] == ')')
					reverse += '(';
				else
					reverse += ')';
			}
			//注意，这里得到的是长度，因为函数longestValidParentheses返回的是最后的长度，而longest的到的还是没有乘以2的长度
			//所以这里的curlength要除以2
            curlength = longestValidParentheses(reverse);
            if(curlength/2 > longest)
                longest = curlength/2;
            return longest*2;
           
        }
    }

}


Regular Expression Matching 
Implement regular expression matching with support for '.' and '*'.'.' Matches any single character.'*' Matches zero or more of the preceding element.The matching should cover the entire input string (not partial).The function prototype should be:bool isMatch(const char *s, const char *p)Some examples:isMatch("aa","a") → falseisMatch("aa","aa") → trueisMatch("aaa","aa") → falseisMatch("aa", "a*") → trueisMatch("aa", ".*") → trueisMatch("ab", ".*") → trueisMatch("aab", "c*a*b") → true

class Solution {
public:
    //动态规划的方法
    //转换方程：f[i][j]表示字符串p从i开始能不能匹配字符串s从j开始
    //f[i][j] = if(p[i] == '.' then = f[i+1][j+1]) else if(a<=p[i]<=z then =  p[i] == s[j]&&P[i+1][j+1]) else 
    //if(p[i-1] == '.') then f[i-1][j] = f[i+1][h](j<=h<=s.length-1)
    //if(a<=p[i-1]<=z) then f[i-1][j] = f[i+1][k](j<=k<=s.length-1 && s[k] == p[i-1])
    bool isMatch(string s, string p) {
        //s、p长度为0的时候返回true
        if(s.length() ==0 && p.length() == 0)
            return true;
   	    if (p.length() == 0)
			return false;
		bool **f = new bool*[p.length() + 1];
		for (int i = 0; i<=p.length(); i++) {
			f[i] = new bool[s.length() + 1];
		}
		for (int i = s.length() - 1; i >= 0; i--)
			f[p.length()][i] = false;
		for (int i = p.length() - 1; i >= 0; i--)
			f[i][s.length()] = false;

		f[p.length()][s.length()] = true;
		//p的最后一个元素独立出来计算，方便后面的循环在使用p[i+1]是不需要进行字符串溢出判断
		for (int j = s.length() - 1; j >= 0; j--) {
			f[p.length() - 1][j] = p[p.length() - 1] == s[j] && f[p.length()][j + 1];
		}
		//对于以[a-z]*/.*结尾的情况进行独立判断，以处理[a-z]*/.*适合s=""的情况 
		//例如p=ab*  s=a
		if(p.length()>=2 && p[p.length()-1] == '*'){
		    if(p[p.length()-2] != '.')
		        f[p.length()-2][s.length()] = true;
		    else{
		        for(int i=s.length(); i>=0; i--)
		            f[p.length()-2][i] = true;
		    }
		}
        for(int i=p.length()-1; i>=0; i--){
            //当前元素为'*',直接跳过
            if(p[i] == '*'){
                continue;
            }
            //这里需要j=s.length(), 不能为j=s.length()-1, 因为对于s="", 而p="f*F*"的情况，结果是true
            //如果是j=s.length()-1的话，那么将不会进入循环，最后返回的值将是false
            for(int j=s.length(); j>=0; j--){
                //如果后面的元素不是'*',那么直接的单个元素匹配
                if(p[i+1] != '*' ){
                    if(p[i] == '.')
                        f[i][j] = f[i+1][j+1];
                    else 
                        f[i][j] = p[i]==s[j]&&f[i+1][j+1];
                }
                //p[i+1] = '*'的情况,进行模式匹配
                else{
                    //对于.*，这种情况，只要f[i+2][k]有一个为true，那么f[i][j]就为true
                    //j<=k<s.length()
                    if(p[i] == '.'){
                        for(int k=j; k<=s.length(); k++)
                            if(f[i+2][k]){
                                f[i][j] = true;
                                break;
                            }
                    }
                    //对于[a-z]*,这种情况，那么如果f[i+2][j]为true,那么就为true，如果不是的话
                    //在p[i] == s[k]的情况下，只要f[i+2][k+1]为true的话，那么f[i][j]就为true
                    else{
                        if(f[i+2][j])
                            f[i][j] = true;
                        else{
                            for (int k = j; k <= s.length(); k++) {
								if (p[i] == s[k]) {
									if (f[i + 2][k + 1]) {
										f[i][j] = true;
										break;
									}
								}
                                else{
                                    f[i][j] = false;
                                    break;
                                }
                            }
                        }
                        
                    }
                }
            }
        }
        return f[0][0];
    }
}


