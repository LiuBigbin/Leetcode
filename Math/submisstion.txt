Perfect Squares 
Given a positive integer n, find the least number of perfect square numbers (for example, 1, 4, 9, 16, ...) which sum to n.For example, given n = 12, return 3 because 12 = 4 + 4 + 4; given n = 13, return 2 because 13 = 4 + 9.
Credits:Special thanks to @jianchao.li.fighter for adding this problem and creating all test cases.

class Solution {
public:
    //使用递归
    int numSquares(int n) {
        double square = sqrt(n);
        square = (int)square;
        return _numSquare(n, square);
    }
    /*
    //超时
    int _numSquare(int n, int begin){
        if(begin*begin == n)
            return 1;
        if(begin == 1)
            return n;
        else{
            if(begin*begin < n){
                return min(_numSquare(n-begin*begin, begin) +1, _numSquare(n, begin-1));
            }
            else{
                return _numSquare(n, begin-1);
            }
        }
            
    }
    */
    /*
    //内存不够
        int _numSquare(int n, int begin){
        int** f = new int*[begin+1];
		for(int a=0; a<=begin; a++)
			f[a] = new int[n+1];
         for(int j=1; j<=n; j++){
            f[1][j] = j;
           
        }
        for(int b=1; b<=begin; b++)
			 f[b][0] = 0;
        
        for(int i=2; i<=begin; i++)
            for(int j=1; j<=n; j++){
                if(i*i<=j)
                    f[i][j] = f[i][j-i*i]+1 > f[i-1][j]? f[i-1][j]:f[i][j-i*i]+1;
                else
                    f[i][j] = f[i-1][j];
            }
     return f[begin][n];
    }
    */
    //采用滚动数组
    	int _numSquare(int n, int begin){
        int* f = new int[n+1];
		
        for(int j=0; j<=n; j++){
            f[j] = j;
           
        }
        for(int i=2; i<=begin; i++)
            for(int j=1; j<=n; j++){
                if(i*i<=j)
                    f[j] = f[j-i*i]+1 > f[j]? f[j]:f[j-i*i]+1;
                else
                    f[j] = f[j];
            }
     return f[n];
    
    }
    
}


Integer to English Words 
Convert a non-negative integer to its english words representation. Given input is guaranteed to be less than 231 - 1.For example,123 ->; "One Hundred Twenty Three"12345 ->; "Twelve Thousand Three Hundred Forty Five"1234567 ->; "One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven"  Did you see a pattern in dividing the number into chunk of words? For example, 123 and 123000.  Group the number by thousands (3 digits). You can write a helper function that takes a number less than 1000 and convert just that chunk to words.  There are many edge cases. What are some good test cases? Does your code work with input such as 0? Or 1000010? (middle chunk is zero and should not be printed out)

class Solution {
public:
	string numberToWords(int num) {
	    if(num==0)
	        return "Zero";
		vector<int> numList;
		while (num != 0) {
			int temp = num % 1000;
			numList.push_back(temp);
			num = num / 1000;
		}
		string result = "";
		for (int i = numList.size() - 1; i >= 0; i--) {
			string temp = getWordNum(numList[i]);
			result += temp;
			if (i> 0 && numList[i] > 0)
				result += base[i - 1] + " ";
		}
		return result.substr(0, result.length()-1);
	}
	Solution() {
		base.push_back("Thousand");
		base.push_back("Million");
		base.push_back("Billion");

		one2Nineteen.push_back("One");
		one2Nineteen.push_back("Two");
		one2Nineteen.push_back("Three");
		one2Nineteen.push_back("Four");
		one2Nineteen.push_back("Five");
		one2Nineteen.push_back("Six");
		one2Nineteen.push_back("Seven");
		one2Nineteen.push_back("Eight");
		one2Nineteen.push_back("Nine");
		one2Nineteen.push_back("Ten");
		one2Nineteen.push_back("Eleven");
		one2Nineteen.push_back("Twelve");
		one2Nineteen.push_back("Thirteen");
		one2Nineteen.push_back("Fourteen");
		one2Nineteen.push_back("Fifteen");
		one2Nineteen.push_back("Sixteen");
		one2Nineteen.push_back("Seventeen");
		one2Nineteen.push_back("Eighteen");
		one2Nineteen.push_back("Nineteen");

		twenty2Ninety.push_back("Twenty");
		twenty2Ninety.push_back("Thirty");
		twenty2Ninety.push_back("Forty");
		twenty2Ninety.push_back("Fifty");
		twenty2Ninety.push_back("Sixty");
		twenty2Ninety.push_back("Seventy");
		twenty2Ninety.push_back("Eighty");
		twenty2Ninety.push_back("Ninety");
	}
	//获得一千以内的数的英语表达式
	string getWordNum(int num) {
		if (num == 0)
			return "";
		string result = "";
		int hundred = num / 100;
		if (hundred != 0)
			result += one2Nineteen[hundred - 1] + " " + "Hundred ";
		int inHundred = num % 100;
		if (inHundred == 0)
			return result;
		if (inHundred <= 19)
			result += one2Nineteen[inHundred - 1] + " ";
		else {
			int ten = inHundred / 10;
			result += twenty2Ninety[ten - 2] + " ";
			int inTen = inHundred % 10;
			if(inTen != 0)
				result += one2Nineteen[inTen - 1] + " ";
		}
		return result;
	}
private:
		vector<string> base;
	vector<string> one2Nineteen;
	vector<string> twenty2Ninety;
}


Missing Number 
Given an array containing n distinct numbers taken from 0, 1, 2, ..., n, find the one that is missing from the array.For example,Given nums = [0, 1, 3] return 2.
Note:Your algorithm should run in linear runtime complexity. Could you implement it using only constant extra space complexity?
Credits:Special thanks to @jianchao.li.fighter for adding this problem and creating all test cases.

class Solution {
public:
    int missingNumber(vector<int>& nums) {
        int total = 0;
        int count = 0;
        for(int i=0; i<nums.size(); i++){
            total += i+1;
            count += nums[i];
        }
        return total-count;
    }
}


Ugly Number II 
Write a program to find the n-th ugly number.Ugly numbers are positive numbers whose prime factors only include 2, 3, 5. For example, 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 is the sequence of the first 10 ugly numbers.Note that 1 is typically treated as an ugly number.  The naive approach is to call isUgly for every number until you reach the nth one. Most numbers are not ugly. Try to focus your effort on generating only the ugly ones.  An ugly number must be multiplied by either 2, 3, or 5 from a smaller ugly number.  The key is how to maintain the order of the ugly numbers. Try a similar approach of merging from three sorted lists: L1, L2, and L3.  Assume you have Uk, the kth ugly number. Then Uk+1 must be Min(L1 * 2, L2 * 3, L3 * 5).
Credits:Special thanks to @jianchao.li.fighter for adding this problem and creating all test cases.

class Solution {
public:
    //因为没有通项公司所以只能从一开始一个个的求，直遍1~n的话，会超时，因为有很多的数值不是ugly number，所以最好的方法
    //就是直接的根据前一个ugly number求出求出下一个值，这样就可以不用绕开不是ugly number的值了。
    //方法：后面的ugly number 都是前面的ugly number乘以2或3或5得到的，设置三个变量idx2、idx3、idx5存储下标，初始值都为0
    //找出数组uglyNumbers[idx2]*2、uglyNumbers[idx3]*3、uglyNumbers[idxe]*5的最小值，最小值即为下一个丑数，
    //同时更新最小值对应的下标，如果多个数字同时为最小值，则它们的下标都要更新(整个过程相当于每一个丑数都可乘以2、3、5得到下一个丑数，
    //每次选取最小的丑数作为新的丑数，如果丑数a乘以2得到当前最新的丑数，那么a不能再乘以2了，所以index2++)
    int nthUglyNumber(int n) {
        int *uglyNumber = new int[n];
        uglyNumber[0] = 1;
        int index2 = 0;
        int index3 = 0;
        int index5 = 0;
        int count = 1;
        while(count<n){
            int next = getMin(uglyNumber[index2]*2, uglyNumber[index3]*3, uglyNumber[index5]*5);
            if(next == uglyNumber[index2]*2)
                index2++;
            if(next == uglyNumber[index3]*3)
                index3++;
            if(next == uglyNumber[index5]*5)
                index5++;
            uglyNumber[count] = next;
            count++;
        }
        return uglyNumber[count-1];
    }
    
    int getMin(int a, int b, int c){
        int temp = a>b?b:a;
        if(c<temp)
            return c;
        return temp;
    }
}


Ugly Number 
Write a program to check whether a given number is an ugly number.Ugly numbers are positive numbers whose prime factors only include 2, 3, 5. For example, 6, 8 are ugly while 14 is not ugly since it includes another prime factor 7.Note that 1 is typically treated as an ugly number.
Credits:Special thanks to @jianchao.li.fighter for adding this problem and creating all test cases.

class Solution {
public:
   //递归
    bool isUgly(int num) {
        if(num <= 0)
            return false;
        
        if(num <= 6)
            return true;
        if(num%2!=0 && num%3!=0 && num%5!=0)
            return false;
        if(num%2 == 0)
            return isUgly(num/2);
        if(num%3 == 0)
            return isUgly(num/3);
        if(num%5 == 0)
            return isUgly(num/5);
            
    }
   
    /*
    //迭代 ，跟递归的效率一样
    bool isUgly(int num) {
        if(num <= 0)
            return false;
        
        while(num>1 && num%2== 0) num /= 2;
        while(num>1 && num%3== 0) num /= 3;
        while(num>1 && num%5== 0) num /= 5;
    
        return num == 1;
            
    }
    */
}


Add Digits 
Given a non-negative integer num, repeatedly add all its digits until the result has only one digit. For example:Given num = 38, the process is like: 3 + 8 = 11, 1 + 1 = 2. Since 2 has only one digit, return it.Follow up:Could you do it without any loop/recursion in O(1) runtime?  A naive implementation of the above process is trivial. Could you come up with other methods?   What are all the possible results?  How do they occur, periodically or randomly?  You may find this Wikipedia article useful.
Credits:Special thanks to @jianchao.li.fighter for adding this problem and creating all test cases.

int addDigits(int num) {
    int count = 0;
        while(num>=10){
            count = 0;
            while(num != 0){
                count += num%10;
                num = num/10;
            }
            num = count;
        }
        return num;



Number of Digit One 
Given an integer n, count the total number of digit 1 appearing in all non-negative integers less than or equal to n.For example: Given n = 13,Return 6, because digit 1 occurred in the following numbers: 1, 10, 11, 12, 13.  Beware of overflow.

class Solution {
public:
    /*
     每10个数, 有一个个位是1, 每100个数, 有10个十位是1, 每1000个数, 有100个百位是1.  
     做一个循环, 每次计算单个位上1得总个数(个位,十位, 百位).  
    例子:
    以算百位上1为例子:   假设百位上是0, 1, 和 >=2 三种情况: 
        case 1: n=3141092, a= 31410, b=92. 计算百位上1的个数应该为 3141 *100 次.
        case 2: n=3141192, a= 31411, b=92. 计算百位上1的个数应该为 3141 *100 + (92+1) 次. 
        case 3: n=3141592, a= 31415, b=92. 计算百位上1的个数应该为 (3141+1) *100 次. 
    以上三种情况可以用 一个公式概括:
    (a + 8) / 10 * m + (a % 10 == 1) * (b + 1);
    */
    int countDigitOne(int n) {
        int ret = 0;
        for(long long m=1; m<=n; m*=10){
            int a = n/m, b = n%m;
            ret += (a+8)/10*m;
            if(a%10 == 1)
                ret += (b+1);
        }
        return ret;
    }
}


Power of Two 
Given an integer, write a function to determine if it is a power of two.
Credits:Special thanks to @jianchao.li.fighter for adding this problem and creating all test cases.

class Solution {
public:
    bool isPowerOfTwo(int n) {
        if(n == 0)
            return false;
        while(n != 1){
            if(n%2 != 0){
                return false;
            }
            n /= 2;      
                
        }
            
       return true;
    }
}


Basic Calculator 
Implement a basic calculator to evaluate a simple expression string.The expression string may contain open ( and closing parentheses ), the plus + or minus sign -, non-negative integers and empty spaces  .You may assume that the given expression is always valid.Some examples:"1 + 1" = 2" 2-1 + 2 " = 3"(1+(4+5+2)-3)+(6+8)" = 23
Note: Do not use the eval built-in library function.

class Solution {
public:
    /*
    两个要点：
    
    1、无括号时，顺序执行
    
    2、有括号时，先执行括号中的
    
    两个栈：
    
    一个存放操作数，每次进栈要注意，如果操作符栈顶元素为'+'/'-'，则需要立即计算。
    
    一个存放操作符（包括括号），每次出现')'时，不断进行出栈计算再进栈，直到弹出'('，说明当前括号内计算完毕。
    */
    int calculate(string s) {
        if(s.length() == 0)
            return 0;
        stack<int> num;
        stack<char> op;
        for(int i=0; i<s.size(); i++){
            if(s[i] == ' ')
                continue;
            if(s[i] == '(')
                op.push(s[i]);
            else if(s[i] == ')'){
                while(op.top() != '('){
                    char ope = op.top();
                    op.pop();
                    int right = num.top();
                    num.pop();
                    int left = num.top();
                    num.pop();
                    if(ope == '+')
                        left += right;
                    else
                        left -= right;
                    num.push(left);
                }
                op.pop();
            }
            else if(s[i] == '-' || s[i] == '+'){
                if(op.size() != 0 && (op.top() == '-' || op.top() == '+')){
                    char ope = op.top();
                    op.pop();
                    int right = num.top();
                    num.pop();
                    int left = num.top();
                    num.pop();
                    if(ope == '+')
                        left += right;
                    else
                        left -= right;
                    num.push(left);
                    
                }
                op.push(s[i]); 
                    
            }
            else{
                int val = s[i++] - '0';
                while(i<s.size() && isdigit(s[i]))
                   val = val*10 + s[i++]-'0';
                i--;
                num.push(val);
            }
        } 
        
        while(op.size()){
            char ope = op.top();
            op.pop();
            int right = num.top();
            num.pop();
            int left = num.top();
            num.pop();
            if(ope == '+')
                left += right;
            else
                left -= right;
            num.push(left);
        }
        return num.top();
    }
}


Rectangle Area 
Find the total area covered by two rectilinear rectangles in a 2D plane.Each rectangle is defined by its bottom left corner and top right corner as shown in the figure.Assume that the total area is never beyond the maximum possible value of int.
Credits:Special thanks to @mithmatt for adding this problem, creating the above image and all test cases.

class Solution {
public:
    int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {
        if(A>E)
            return computeArea(E, F, G, H, A, B, C, D);
        int area = (C-A)*(D-B)+(G-E)*(H-F);
        //小矩形在大矩形里面
        if(E>A&&F>B&&G<C&&H<D)
            return (C-A)*(D-B);
        //两矩形交叉
        if(E<C ){
			if((F>=B && F<D)){
			    int width = (C<G?C:G) - E;
			    int height = (H<D?H:D) - F;
			    return area - width*height;
			}
                
			else if(F<B &&H>B){
			    int width = (C<G?C:G) - E;
			    int height = (H<D?H:D) - B;
			    return area - width*height;
			}
            
        }
        return area;
    }
}


Count Primes 
Description:Count the number of prime numbers less than a non-negative number, n.
Credits:Special thanks to @mithmatt for adding this problem and creating all test cases.  Let's start with a isPrime function. To determine if a number is prime, we need to check if it is not divisible by any number less than n. The runtime complexity of isPrime function would be O(n) and hence counting the total prime numbers up to n would be O(n2). Could we do better?    As we know the number must not be divisible by any number >; n / 2, we can immediately cut the total iterations half by dividing only up to n / 2. Could we still do better?    Let's write down all of 12's factors:2 × 6 = 123 × 4 = 124 × 3 = 126 × 2 = 12As you can see, calculations of 4 × 3 and 6 × 2 are not necessary. Therefore, we only need to consider factors up to &amp;radic;n because, if n is divisible by some number p, then n = p × q and since p &amp;le; q, we could derive that p &amp;le; &amp;radic;n.Our total runtime has now improved to O(n1.5), which is slightly better. Is there a faster approach?public int countPrimes(int n) {   int count = 0;   for (int i = 1; i <; n; i++) {      if (isPrime(i)) count++;   }   return count;}private boolean isPrime(int num) {   if (num <;= 1) return false;   // Loop's ending condition is i * i <;= num instead of i <;= sqrt(num)   // to avoid repeatedly calling an expensive function sqrt().   for (int i = 2; i * i <;= num; i++) {      if (num % i == 0) return false;   }   return true;}    The Sieve of Eratosthenes is one of the most efficient ways to find all prime numbers up to n. But don't let that name scare you, I promise that the concept is surprisingly simple.Sieve of Eratosthenes: algorithm steps for primes below 121. "Sieve of Eratosthenes Animation" by SKopp is licensed under CC BY 2.0.We start off with a table of n numbers. Let's look at the first number, 2. We know all multiples of 2 must not be primes, so we mark them off as non-primes. Then we look at the next number, 3. Similarly, all multiples of 3 such as 3 × 2 = 6, 3 × 3 = 9, ... must not be primes, so we mark them off as well. Now we look at the next number, 4, which was already marked off. What does this tell you? Should you mark off all multiples of 4 as well?    4 is not a prime because it is divisible by 2, which means all multiples of 4 must also be divisible by 2 and were already marked off. So we can skip 4 immediately and go to the next number, 5. Now, all multiples of 5 such as 5 × 2 = 10, 5 × 3 = 15, 5 × 4 = 20, 5 × 5 = 25, ... can be marked off. There is a slight optimization here, we do not need to start from 5 × 2 = 10. Where should we start marking off?    In fact, we can mark off multiples of 5 starting at 5 × 5 = 25, because 5 × 2 = 10 was already marked off by multiple of 2, similarly 5 × 3 = 15 was already marked off by multiple of 3. Therefore, if the current number is p, we can always mark off multiples of p starting at p2, then in increments of p: p2 + p, p2 + 2p, ... Now what should be the terminating loop condition?    It is easy to say that the terminating loop condition is p <; n, which is certainly correct but not efficient. Do you still remember Hint #3?    Yes, the terminating loop condition can be p <; &amp;radic;n, as all non-primes &amp;ge; &amp;radic;n must have already been marked off. When the loop terminates, all the numbers in the table that are non-marked are prime.The Sieve of Eratosthenes uses an extra O(n) memory and its runtime complexity is O(n log log n). For the more mathematically inclined readers, you can read more about its algorithm complexity on Wikipedia.public int countPrimes(int n) {   boolean[] isPrime = new boolean[n];   for (int i = 2; i <; n; i++) {      isPrime[i] = true;   }   // Loop's ending condition is i * i <; n instead of i <; sqrt(n)   // to avoid repeatedly calling an expensive function sqrt().   for (int i = 2; i * i <; n; i++) {      if (!isPrime[i]) continue;      for (int j = i * i; j <; n; j += i) {         isPrime[j] = false;      }   }   int count = 0;   for (int i = 2; i <; n; i++) {      if (isPrime[i]) count++;   }   return count;}  

class Solution {
public:
    int countPrimes(int n) {
        if(n <= 2)
            return 0;
        bool* isPrimes = new bool[n];
        for(int i=2; i<n; i++)
            isPrimes[i] = true;
        for( int j=2; j*j<n; j++){
            for(int k = j*j; k<n; k+=j)
                isPrimes[k] = false;
        }
        int count = 0;
        for(int i=2; i<n; i++)
            if(isPrimes[i])
                count++;
        return count;
    }
}


Happy Number 
Write an algorithm to determine if a number is "happy".A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers.Example:&amp;nbsp;19 is a happy number12 + 92 = 8282 + 22 = 6862 + 82 = 10012 + 02 + 02 = 1
Credits:Special thanks to @mithmatt and @ts for adding this problem and creating all test cases.

class Solution {
public:
    bool isHappy(int n) {
        if(n == 0)
            return false;
        set<int> happend;
        int count = 0;
        while(n!=1){
            count = 0;
            while(n){
                count += (n%10)*(n%10);
                n /= 10;
            }
            n = count;
            if(happend.count(count) == 1)
                return false;
            happend.insert(count);
        }
        return true;
    }
    
}


Factorial Trailing Zeroes 
Given an integer n, return the number of trailing zeroes in n!.
Note: Your solution should be in logarithmic time complexity.
Credits:Special thanks to @ts for adding this problem and creating all test cases.

class Solution {
public:

    /*对n!做质因数分解n!=2x*3y*5z*...
    
    显然0的个数等于min(x,z)，并且min(x,z)==z
    
    证明：
    
    对于阶乘而言，也就是1*2*3*...*n
    [n/k]代表1~n中能被k整除的个数
    那么很显然
    [n/2] > [n/5] (左边是逢2增1，右边是逢5增1)
    [n/2^2] > [n/5^2](左边是逢4增1，右边是逢25增1)
    ……
    [n/2^p] > [n/5^p](左边是逢2^p增1，右边是逢5^p增1)
    随着幂次p的上升，出现2^p的概率会远大于出现5^p的概率。
    因此左边的加和一定大于右边的加和，也就是n!质因数分解中，2的次幂一定大于5的次幂
    */
    int trailingZeroes(int n) {
        int ret = 0;

        while(n){
            ret += n/5;
            n /= 5;
        }
        return ret;
    }
}


Excel Sheet Column Number 
Related to question Excel Sheet Column TitleGiven a column title as appear in an Excel sheet, return its corresponding column number.For example:    A -&amp;gt; 1    B -&amp;gt; 2    C -&amp;gt; 3    ...    Z -&amp;gt; 26    AA -&amp;gt; 27    AB -&amp;gt; 28 
Credits:Special thanks to @ts for adding this problem and creating all test cases.

class Solution {
public:
    int titleToNumber(string s) {
        //二十六进制
        int num = 0;
        for(int i=0; i<=s.size()-1; i++){
            num = num*26+(int)(s[i] - 64);
        }
        return num;
    }
}


Excel Sheet Column Title 
Given a positive integer, return its corresponding column title as appear in an Excel sheet.For example:    1 ->; A    2 ->; B    3 ->; C    ...    26 ->; Z    27 ->; AA    28 ->; AB 
Credits:Special thanks to @ifanchu for adding this problem and creating all test cases.

class Solution {
public:
    string convertToTitle(int n) {
        string result = "";
        if(n==0)
            return result;
        int temp = 0;
        while(n){
            n--;
            temp = n%26;
            result = (char)(temp+65) + result;
            n /= 26;
            
        }
        
        return result;
    }
}


Fraction to Recurring Decimal 
Given two integers representing the numerator and denominator of a fraction, return the fraction in string format.If the fractional part is repeating, enclose the repeating part in parentheses.For example,Given numerator = 1, denominator = 2, return "0.5".Given numerator = 2, denominator = 1, return "2".Given numerator = 2, denominator = 3, return "0.(6)".
Credits:Special thanks to @Shangrila for adding this problem and creating all test cases.

class Solution {
public:
	//这道题目要注意两点：
	//1:INT_MIN转成整数的时候会溢出，中间运算numerator = numerator%denominator*10;也有可能会溢出
	//计算循环的时候，主要根据余数在前面是否出现来判断是否循环，这里每进行模运算后，得到的余数要乘以10,
	//才能作为新的余数进行下一步的计算
	string fractionToDecimal(int numerator, int denominator) {
		return _fractionToDecimal(numerator, denominator);
	}
	//采用的是long long 的变量，避免了溢出
	string _fractionToDecimal(long long  numerator, long long denominator) {
		if (numerator == 0)
			return "0";
		//排除掉所有的有负数参数的情况,因为下面的计算都是默认为正整数的
		if (numerator<0 && denominator>0)
			return  "-" + _fractionToDecimal(-numerator, denominator);
		if (numerator>0 && denominator<0)
			return "-" + _fractionToDecimal(numerator, -denominator);
		if (numerator<0 && denominator<0)
			return  _fractionToDecimal(-numerator, -denominator);
		string ret = "";
		//这里要使用long long类型（有可能是-INT_MIN/1）
		long long num = numerator / denominator;
		//计算商的整数部分
		if (num <= 9)
			ret += num + '0';
		else {
			while (num) {
				int digit = num % 10;
				ret = (char)(digit + '0') + ret;
				num /= 10;
			}
		}
		//模运后得到的余数都要先乘以10
		numerator = numerator%denominator * 10;
		if (numerator == 0)
			return ret;
		ret += '.';
		unordered_map<int, int> isvisited;

		string doc = "";
		int index = 0;
		//记录乘以10后出现的余数
		isvisited[numerator] = index++;
		while (numerator) {
			//每一个余数必须大除数才可以进行除法
			while (numerator<denominator) {
				doc += "0";
				numerator *= 10;
				//记录中间出现的余数   
				if (isvisited.count(numerator) == 0)
					isvisited[numerator] = index++;
				else {
					string temp = doc.substr(isvisited[numerator], doc.length() - isvisited[numerator]);
					doc = doc.substr(0, isvisited[numerator]);
					doc += '(';
					doc += temp;
					doc += ")";
					return ret + doc;
				}
			}
			doc += (numerator / denominator + '0');
			//这里必须先乘以10
			numerator = numerator%denominator * 10;
			if (isvisited.count(numerator) == 0)
				isvisited[numerator] = index++;
			else {
				string temp = doc.substr(isvisited[numerator], doc.length() - isvisited[numerator]);
				doc = doc.substr(0, isvisited[numerator]);
				doc += '(';
				doc += temp;
				doc += ")";
				return ret + doc;
			}

		}
		return ret + doc;
	}
}


Max Points on a Line 
Given n points on a 2D plane, find the maximum number of points that lie on the same straight line.

/**
 * Definition for a point.
 * struct Point {
 *     int x;
 *     int y;
 *     Point() : x(0), y(0) {}
 *     Point(int a, int b) : x(a), y(b) {}
 * };
 */
class Solution {
public:
 //生成二维数组isline记录点i和j是否已经连过线了，在后面的点连线中就可以根据这个来减少不必要的连线
 //注意，这里可以允许重复的点出现
 int maxPoints(vector<Point>& points) {
		int size = points.size();
		if (size <= 2)
			return size;
		bool **isline = new bool*[size];
		for (int i = 0; i<size; i++)
			isline[i] = new bool[size];
		for (int i = 0; i<size; i++)
			for (int j = 0; j<size; j++) {
				isline[i][j] = false;
			}
		int ans = 0;
		//选择第一个点
		for (int i = 0; i<size; i++) {
			isline[i][i] = true;
			bool vertical = false;
			int tempans = 1;
			//选择第二个点
			for (int j = i + 1; j<size&&!isline[i][j]; j++) {
			    tempans++;
			    isline[i][j] = true;
			    //如果第二个点和第一个点重叠，直接忽略，遍历下一个点
				if(points[i].x == points[j].x && points[i].y == points[j].y){
				    continue;
				}
			    //计算斜率，这里记得要double 啊，尼玛在这里耗了很久！！！
				double k = 0;
				if (points[i].x == points[j].x)
					vertical = true;
				else {
					k = (double)(points[i].y - points[j].y) / (double)(points[i].x - points[j].x);
				}
				//查找在第一和第二点连成线上的点
				for (int h = 0; h<size; h++) {
				    if (isline[i][h])
						continue;
					//如果有跟第一个点重复的，那么直接tempans加1，继续下一个点
					if(points[h].x == points[i].x && points[h].y == points[i].y){
					    tempans++;
						isline[i][h] = true;
						continue;
					}
					if (vertical) {
						if (points[i].x == points[h].x) {
							tempans++;
							isline[i][h] = true;
						}
					}	
					else {
						if (points[i].x != points[h].x) {
						    //计算斜率，这里记得要double 啊，尼玛在这里耗了很久！！！
							double tempk = (double)(points[i].y - points[h].y) / (double)(points[i].x - points[h].x);
							if (tempk == k) {
								tempans++;
								isline[i][h] = true;
							}
						}
						
					}
				}
				if (tempans > ans)
					ans = tempans;
				//继续查找第二个点，这里tempans赋值1
				tempans = 1;
			}
			//有可能循环结束了，所以还要在判断一下tempans是否大于ans
			if (tempans > ans)
				ans = tempans;
		}
		return ans;
	}
}


Sqrt(x) 
Implement int sqrt(int x).Compute and return the square root of x.

class Solution {
public:

    //超时！！！
    /*
    int mySqrt(int x) {
        if(x == 1)
            return 1;
        long long medium = x/2;
        while(medium>0 && medium*medium>x)
            medium--;
        return medium;
    }
    */
    //二分查找
     // 8ms
     /*
     int mySqrt(int x) {
        if(x == 1)
            return 1;
        int end = x/2;
        int begin = 0;
        //防止溢出
        unsigned long long temp;
        while(begin<end){
            //防止溢出
            unsigned long long medium = (begin+end)/2;
            temp = medium*medium;
            if(temp == x)
                return medium;
            if(temp>x){
                temp = (medium-1)*(medium-1);
                if(temp < x)
                    return medium-1;
                end = medium-1;
            }
            else{
                temp = (medium+1)*(medium+1);
                if(temp>x)
                    return medium;
                begin = medium+1;
            }
        }
        return begin;
    }
    */
    
    //牛顿迭代法  8ms
    //迭代公式xi+1= (xi + n/xi) / 2
    
    int mySqrt(int x) {
        if(x <= 1)
            return x;
        double cur = 1;
        double pre = cur;
        do{
            pre = cur;
            cur = (pre+x/pre)/2.0;
        }while(abs(pre-cur)>0.00001);
        return (int)pre;
    }
    
   
    
}


Plus One 
Given a non-negative number represented as an array of digits, plus one to the number.The digits are stored such that the most significant digit is at the head of the list.

class Solution {
public:
    vector<int> plusOne(vector<int>& digits) {
        vector<int> result;
        if(digits.size() == 0){
            result.push_back(1);
            return result;
        }
        int carry = 1;
        for(int i=digits.size()-1; i>=0; i--){
            carry = carry + digits[i];
            result.push_back(carry%10);
            carry /= 10;
        }
        if(carry != 0)
            result.push_back(carry);
            
        reverse(result.begin(), result.end());
        return result;
    }
}


Valid Number 
Validate if a given string is numeric.Some examples:"0" =>; true"   0.1  " =>; true"abc" =>; false"1 a" =>; false"2e10" =>; true
Note: It is intended for the problem statement to be ambiguous. You should gather all requirements up front before implementing one.Update (2015-02-10):The signature of the C++ function had been updated. If you still see your function signature accepts a const char * argument, please click the reload button  to reset your code definition.

class Solution {
public:
    //e后面的数值不能有小数点,只能允许有一个e出现
    //允许00003这样的数值
    //允许3.这样的数值
    //允许.3这样的数值
    bool isNumber(string s) {
        bool can_doc = true;
        bool can_e = true;
        if(s.size() == 0)
            return false;
        //去掉前面的空格
        int index = 0;
        while(index<s.size() && s[index] == ' ')index++;
        if(index == s.size())
            return false;
        int end = s.size()-1;
        while(end>=0 && s[end] == ' ') end--;
        //忽略第一个正负符号
        if(s[index] == '-' || s[index] == '+')
            index++;
        if(s[index] == '.'){
            index++;
            can_doc = false;
        }
        if(index>end)
            return false;
        //第一个字符不允许为e
        if(s[index] == 'e')
            return false;
        for(; index<=end; index++){
            if('0'<=s[index] && s[index]<='9')
                continue;
            //e后面的数值不允许有小数点
            if(s[index] == 'e'){
                if(!can_e)
                    return false;
                can_e = false;
                can_doc = false;
                if(index == end)
                    return false;
                if(s[index+1] == '-' || s[index+1] == '+')
                    index++;
                if(index == end)
                    return false;
                continue;
            }
            //只允许一个小数点
            if(s[index] == '.'){
                if(!can_doc)
                    return false;
                can_doc = false;
                
                continue;
            }
            return false;
            
        }
        return true;
    }
}


Add Binary 
Given two binary strings, return their sum (also a binary string).For example,a = "11"b = "1"Return "100".

class Solution {
public:
    string addBinary(string a, string b) {
        int smallLength = a.size()>b.size()? b.size(): a.size();
        
        string result = "";
        int carry = 0;
        int aEnd = a.size()-1;
        int bEnd = b.size()-1;
        for(int i=smallLength-1; i>=0; i--){
            carry = (a[aEnd--]-'0') + (b[bEnd--]-'0') + carry;
            result = (char)(carry%2 +'0') + result;
            carry /= 2;
        }
        if(aEnd == -1){
            for(; bEnd>=0; bEnd--){
                carry = (b[bEnd]-'0') + carry;
                result = (char)(carry%2+'0') + result;
                carry /= 2;
            }
        }
        if(bEnd == -1){
            for(; aEnd>=0; aEnd--){
                carry = (a[aEnd]-'0') + carry;
                result = (char)(carry%2+'0') + result;
                carry /= 2;
            }
        }
       if(carry != 0)
          result = (char)(carry+'0') + result;
         return result;
    }
}


Permutation Sequence 
The set [1,2,3,&amp;#8230;,n] contains a total of n! unique permutations.By listing and labeling all of the permutations in order,We get the following sequence (ie, for n = 3):"123""132""213""231""312""321"Given n and k, return the kth permutation sequence.
Note: Given n will be between 1 and 9 inclusive.

class Solution {
public:
    string getPermutation(int n, int k) {
        int *a = new int[n];
        for(int i=0; i<n; i++)
            a[i] = i+1;
        string ret = "";
        int m = n;
        while(k){
            int rest = getnumber(--m);
            int index = k/rest;
            if(k%rest == 0)
                index--;
            ret += getval(a, index, n);
            k %= rest;
        }
        for(int i=n-1; i>=0; i--){
            if(a[i] != -1)
                ret += ('0'+a[i]);
        }
        return ret;
    }
    
    int getnumber(int n){
        int ret = 1;
        for(int i=1; i<=n; i++){
            ret *= i;
        }
        return ret;
    }
    
    char getval(int *a, int index, int n){
        for(int i=0; i<n; i++){
            if(a[i] == -1)
                continue;
            if(index == 0){
                int temp = a[i];
                a[i] = -1;
                return temp+'0';
            }
            else
               index--;
        }
    }
}


Pow(x, n) 
Implement pow(x, n).

class Solution {
public:
    //TMD, temp的类型要double啊，靠！还有要考虑n为负整数！！！，还有负数n转换为整数的时候，不能直接的变为-n，因为有可能会溢出
    //所以可以先将n除以2，再来转为正整数，再根据n是否为偶数还是奇数来确定返回的是什么！！！，还有判断n是否为奇偶数的时候，要
    //使用n%2 != 0,而不能直接的使用n%2 != 1,因为负奇数的余数是-1 ！！！
    double myPow(double x, int n) {
        if(n<0){
            double temp = myPow(x, -(n/2));
            if(n%2 != 0)
                return 1/(temp*temp*x);
            return 1/(temp*temp);
        }
            
        if(n == 0)
            return 1;
        double temp = myPow(x, n/2);
        if(n%2 != 0){
            return temp*temp*x;
        }
         
        return temp*temp;
    }
}


Multiply Strings 
Given two numbers represented as strings, return multiplication of the numbers as a string.
Note: The numbers can be arbitrarily large and are non-negative.

class Solution {
public:
    string multiply(string num1, string num2) {
        if(num1 == "0" || num2 == "0")
            return "0";
        reverse(num1.begin(), num1.end());
        reverse(num2.begin(), num2.end());
        
        int length = num1.size()+num2.size();
        string ret = "";
        for(int i=0; i<length; i++){
            ret += "0";
        }
        int carry = 0;
        int index;
        for(int i=0; i<num1.size(); i++){
            index = i;
            carry = 0;
            for(int j=0; j<num2.size(); j++, index++){
                carry += (num1[i]-'0')*(num2[j]-'0');
                carry += (ret[index]-'0');
                ret[index] = (carry%10+'0');
                carry /= 10;
            }
            if(carry != 0)
                ret[index] = carry+'0';
        }
       
        reverse(ret.begin(), ret.end());
        index = 0;
        while(ret[index] == '0')
            index++;
        return ret.substr(index, ret.length()-index);
    }
}


Divide Two Integers 
Divide two integers without using multiplication, division and mod operator.If it is overflow, return MAX_INT.

class Solution {
public:
    int divide(int dividend, int divisor) {
        //为了防止溢出，这里直接的将dividend和divisor赋值给long long 类型的变量
        long long newdividend = dividend;
        long long newdivisor = divisor;
        if(dividend == 0)
            return 0;
        if(divisor == 1)
            return dividend;
        if(dividend == INT_MIN && divisor == -1)
            return INT_MAX;
        if(dividend < 0 && divisor < 0)
            return _dividend(-newdividend, -newdivisor);
        if(dividend < 0)
            return -_dividend(-newdividend, newdivisor);
        if(divisor<0)
            return -_dividend(newdividend, -newdivisor);
        return _dividend(newdividend, newdivisor);
        
    }
    
    //直接的将被除数减去除数，看看总共可以减多少次，次数就是商，这样的话会超时
    //所以可以先将除数扩大，每次扩大两倍直到除数最接近被除数为止（此时除数应该小于被除数），建设扩大了i次两倍，
    //那么此时商的中间解为2*i,
    //然后在对余数进行同样的操作
    int _dividend(long long dividend, long long divisor){
        long long  temp ;
        int count = 0;
        int ret = 0;
        while(dividend>=divisor){
            temp = divisor<<1;
            //每次都要初始为0
            count = 0;
            if(temp > dividend)
                return ret+1;
            //除数先左移count次
            while(temp<dividend){
                count++;
                temp = (temp<<1);
                
            }
            //商每次都要加上对应的2*count值
            ret = ret + (1<<count);
            //减去扩大后所剩余的数，再赋值给被除数
            dividend = dividend - (temp>>1);
        }
        
        return ret;
    }
    

}


Roman to Integer 
Given a roman numeral, convert it to an integer.Input is guaranteed to be within the range from 1 to 3999.

class Solution {
public:
    int romanToInt(string s) {
        if(s.length() == 0)
            return 0;
        int number = 0;
        //记录前一个值
        int predata = 0;
        for(int i=s.length()-1; i>=0; i--){
            int data = charToInt(s[i]);
            //如果当前的值小于上一个值，那么要减去当前的值，否则加上当前的值
            if(data<predata)
                number -= data;
            else
                number += data;
            predata = data;
        }
        return number;
    }
    
    int charToInt(char roma){
        int data = 0;  
  
        switch (roma) {  
            case 'I':  
                data = 1;  
                break;  
            case 'V':  
                data = 5;  
                break;  
            case 'X':  
                data = 10;  
                break;  
            case 'L':  
                data = 50;  
                break;  
            case 'C':  
                data = 100;  
                break;  
            case 'D':  
                data = 500;  
                break;  
            case 'M':  
                data = 1000;  
                break;  
        }  
  
        return data;  
    }
}


Integer to Roman 
Given an integer, convert it to a roman numeral.Input is guaranteed to be within the range from 1 to 3999.

class Solution {
public:
    //转换的时候有两个特殊的值4和9，对于9，如果当前对应的是十位(X),那么转换后转换后应该是XC,(X跳过L加C)，
    //如果是百位C，那么应该是CM（C跳过D加M）；为4的时候，如果是十位，为XL(X直加上后面的一位)，其他位数的
    //也是同样的道理
    string intToRoman(int num) {
        if(num == 0)
            return "";
        string ret = "";
        int i=0;
        while(num){
            int val = num%10;
            num /= 10;
            string romanstr = valToRoma(val, i);
            ret = romanstr + ret;
            i += 2;
        }
       return ret; 
        
    }
    
    string valToRoma(int val, int i){
        string ret = "";
        if(val == 4)
            ret = ret+roman[i]+roman[i+1];
        else if(val == 9)
            ret = ret+roman[i]+roman[i+2];
        else if(val == 5)
            ret = ret+roman[i+1];
        if(ret != "")
            return ret;
        if(val<4)
            for(int j=0; j<val; j++)
                ret += roman[i];
        else{
            ret += roman[i+1];
            for(int j=0; j<val-5; j++)
               ret += roman[i];
        }
        return ret;   

    }
    
private:
    char roman[7] = {'I', 'V', 'X', 'L', 'C', 'D', 'M'};
}


Palindrome Number 
Determine whether an integer is a palindrome. Do this without extra space.click to show spoilers.Some hints:Could negative integers be palindromes? (ie, -1)If you are thinking of converting the integer to string, note the restriction of using extra space.You could also try reversing an integer. However, if you have solved the problem "Reverse Integer", you know that the reversed integer might overflow. How would you handle such case?There is a more generic way of solving this problem.

class Solution {
public:
    //不能将x转换为string，因为这里不能产生额外的空间，直接将x反转要注意有可能会溢出。
    //负数不是回文整数，0为回文整数
    bool isPalindrome(int x) {
       
        if(x < 0)
            return false;
        long long reverse = 0;
        int temp = x;
        while(temp){
            reverse = reverse*10+temp%10;
            temp /= 10;
        }
        while(x){
            if(reverse%10 != x%10)
                return false;
            reverse /= 10;
            x /= 10;
        }
        return true;
    }
}


String to Integer (atoi) 
Implement atoi to convert a string to an integer.
Hint: Carefully consider all possible input cases. If you want a challenge, please do not see below and ask yourself what are the possible input cases.Notes: It is intended for this problem to be specified vaguely (ie, no given input specs). You are responsible to gather all the input requirements up front. Update (2015-02-10):The signature of the C++ function had been updated. If you still see your function signature accepts a const char * argument, please click the reload button  to reset your code definition.spoilers alert... click to show requirements for atoi.Requirements for atoi:The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value.The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function.If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed.If no valid conversion could be performed, a zero value is returned. If the correct value is out of the range of representable values, INT_MAX (2147483647) or INT_MIN (-2147483648) is returned.

class Solution {
public:
    int myAtoi(string str) {
        if(str.size() == 0)
            return 0;
        int native = 1;
        long long num = 0;
        int index = 0;
        //除去前面的空号
        for(; index<str.size(); index++){
            if(str[index] == ' ')
                continue;
		    break;
        }
        //第一个元素不是+、-、0-9时，直接返回0
		if(str[index] != '-' && str[index] != '+' && (str[index]<48 || str[index] > 57))
			return 0;
		if(str[index] == '-'){
			native = -1;
			index++;
		}
		else if(str[index] == '+'){
		    index++;
		}
        for(;index<str.size(); index++){
            //字符串中如果出现了非0-9的数值，则返回前面的数值，后面的直接忽略。
			if(str[index]<48 || str[index] >57)
				break;
            num = num*10+(str[index]-'0');
            //有可能num会溢出，所以只要是num大于INT_MAX+1就直接退出了，因为INT_MAX+1会溢出，所以要使用num-1>INT_MAX
            if(num-1>INT_MAX)
                break;
        }
        if(native == -1 && -num<INT_MIN)
            return INT_MIN;
        if(native == 1 && num>INT_MAX)
            return INT_MAX;
        
        return num*native;
    }
}


Reverse Integer 
Reverse digits of an integer.Example1: x =  123, return  321Example2: x = -123, return -321click to show spoilers.Have you thought about this?Here are some good questions to ask before coding. Bonus points for you if you have already thought through this!If the integer's last digit is 0, what should the output be? ie, cases such as 10, 100.Did you notice that the reversed integer might overflow? Assume the input is a 32-bit integer, then the reverse of 1000000003 overflows. How should you handle such cases?For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.Update (2014-11-10):Test cases had been added to test the overflow behavior.

class Solution {
public:
    int reverse(int x) {
        long long result = 0;
        bool native = x>0? false: true;
        while(x){
            result = result*10+x%10;
            x /= 10;
        }
        if(!native && result>INT_MAX)
            return 0;
        if(native && result<INT_MIN)
            return 0;
        return result;
    }
}


Add Two Numbers 
You are given two linked lists representing two non-negative numbers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.Input: (2 ->; 4 ->; 3) + (5 ->; 6 ->; 4)Output: 7 ->; 0 ->; 8

/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        if(l1 == NULL || l2 == NULL)
            return l1 == NULL? l2: l1;
        ListNode *head = new ListNode(0);
        ListNode *cur = head;
        int carry = 0;
        while(l1 != NULL && l2 != NULL){
            carry = carry + l1->val + l2->val;
            ListNode *node = new ListNode(carry%10);
            cur->next = node;
            cur = cur->next;
            carry /= 10;
            l1 = l1->next;
            l2 = l2->next;
        }
        
        if(l1 != NULL){
            while(l1 != NULL){
                carry = carry + l1->val;
                ListNode *node = new ListNode(carry%10);
                cur->next = node;
                cur = cur->next;
                carry /= 10;
                l1 = l1->next;
            }
        }
        if(l2 != NULL){
            while(l2 != NULL){
                carry = carry + l2->val;
                ListNode *node = new ListNode(carry%10);
                cur->next = node;
                cur = cur->next;
                carry /= 10;
                l2 = l2->next;
            }
        }
        if(carry != 0){
            ListNode *node = new ListNode(carry);
            cur->next = node;
        }
        cur = head;
        head = head->next;
        delete cur;
        return head;
    }
}


