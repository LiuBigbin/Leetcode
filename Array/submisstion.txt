Game of Life 
According to the Wikipedia's article: "The Game of Life, also known simply as Life, is a cellular automaton devised by the British mathematician John Horton Conway in 1970."Given a board with m by n cells, each cell has an initial state live (1) or dead (0). Each cell interacts with its eight neighbors (horizontal, vertical, diagonal) using the following four rules (taken from the above Wikipedia article):Any live cell with fewer than two live neighbors dies, as if caused by under-population.Any live cell with two or three live neighbors lives on to the next generation.Any live cell with more than three live neighbors dies, as if by over-population..Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.Write a function to compute the next state (after one update) of the board given its current state.Follow up: Could you solve it in-place? Remember that the board needs to be updated at the same time: You cannot update some cells first and then use their updated values to update other cells.In this question, we represent the board using a 2D array. In principle, the board is infinite, which would cause problems when the active area encroaches the border of the array. How would you address these problems?
Credits:Special thanks to @jianchao.li.fighter for adding this problem and creating all test cases.

class Solution {
public:
    //四种状态：0->0, 1->1, 0->1, 1->0,将0->1标记为2，将1->0标记为3，其余的不标记
    void gameOfLife(vector<vector<int>>& board) {
        if(board.size() == 0 || board[0].size() == 0)
            return ;
        int count = 0;
        for(int i=0; i<board.size(); i++)
            for(int j=0; j<board[i].size(); j++){
                 count = 0;
                 //遍历邻居节点
                 for(int m = i>1?(i-1):0; m<=i+1 && m<board.size(); m++)
                     for(int n = j>1?(j-1):0; n<=j+1 && n<board[0].size(); n++){
                         if(m==i && n== j)
                             continue;
                         if(board[m][n]%2 == 1)
                             count++;
                            
                     }
                 //当节点的值为1时，如果count值为2或3，节点存活为1，否则为0
                 if(board[i][j] == 1 && (count<2 || count>3))
                    board[i][j] = 3;
                 else if(board[i][j] == 0 && count == 3)
                     board[i][j] = 2;
                         
            }
            for(int i=0; i<board.size(); i++)
                for(int j=0; j<board[i].size(); j++){
                    if(board[i][j] == 2)
                        board[i][j] = 1;
                    else if(board[i][j] == 3)
                        board[i][j] = 0;
                }
        
    }
}


Find the Duplicate Number 
Given an array nums containing n + 1 integers where each integer is between 1 and n (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one.
Note:You must not modify the array (assume the array is read only).You must use only constant, O(1) extra space.Your runtime complexity should be less than O(n2).There is only one duplicate number in the array, but it could be repeated more than once.
Credits:Special thanks to @jianchao.li.fighter for adding this problem and creating all test cases.

class Solution {
public:
	//抽屉原理，每次查找小于n/2的数的个数，如果个数小于其实数到n/2数之间的数量，
	//说明重复的数大于n/2,否则的话说明重复的数就在起始数到n/2之间
     int findDuplicate(vector<int>& nums) {
        int min = 1;
		int max = nums.size()-1;
		while(min < max-1){
			int median = min + (max - min)/2;
			int count = 0;
			for(int i=0; i<nums.size(); i++){
				if(nums[i] < median)
					count++;
			}
			if(count>median-1){
				max = median;
			}
			else{
				min = median;
			}
		}
		int mincount = 0;
		for(int i=0; i<nums.size(); i++)
			if(nums[i] == min)
				mincount++;
		if(mincount > 1)
			return min;
		else return max;
		
    }
}


Move Zeroes 
Given an array nums, write a function to move all 0's to the end of it while maintaining the relative order of the non-zero elements.For example, given nums  = [0, 1, 0, 3, 12], after calling your function, nums should be [1, 3, 12, 0, 0].
Note:You must do this in-place without making a copy of the array.Minimize the total number of operations.
Credits:Special thanks to @jianchao.li.fighter for adding this problem and creating all test cases.

class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        int i=0;
        int j = nums.size();
        int index = 0;
        while(i<j){
            //找到下一个不为0的下标
            while(j>i && nums[i] == 0)i++;
            if (i < j) {
				nums[index++] = nums[i++];
				
			}
        }
        for(; index<j; index++)
            nums[index] = 0;
        
    }
}


Missing Number 
Given an array containing n distinct numbers taken from 0, 1, 2, ..., n, find the one that is missing from the array.For example,Given nums = [0, 1, 3] return 2.
Note:Your algorithm should run in linear runtime complexity. Could you implement it using only constant extra space complexity?
Credits:Special thanks to @jianchao.li.fighter for adding this problem and creating all test cases.

class Solution {
public:
    int missingNumber(vector<int>& nums) {
        int total = 0;
        int count = 0;
        for(int i=0; i<nums.size(); i++){
            total += i+1;
            count += nums[i];
        }
        return total-count;
    }
}


Product of Array Except Self 
Given an array of n integers where n >; 1, nums, return an array output such that output[i] is equal to the product of all the elements of nums except nums[i].Solve it without division and in O(n).For example, given [1,2,3,4], return [24,12,8,6].Follow up:Could you solve it with constant space complexity? (
Note: The output array does not count as extra space for the purpose of space complexity analysis.)

class Solution {
public:
    vector<int> productExceptSelf(vector<int>& nums) {
        if(nums.size() == 0)
             return {};
        vector<int> left;
        left.push_back(1);
        for(int i=1; i<nums.size(); i++){
            left.push_back(left[i-1]*nums[i-1]);
        }
        int right = 1;
        for(int j=nums.size()-1; j>=0; j--){
            left[j] = left[j]*right;
            right = right*nums[j];
        }
        return left;
    }
}


Majority Element II 
Given an integer array of size n, find all elements that appear more than &amp;lfloor; n/3 &amp;rfloor; times. The algorithm should run in linear time and in O(1) space.  How many majority elements could it possibly have?  Do you have a better hint? Suggest it!

class Solution {
public:
    //该问题中最多有两个主元素按照一下的思路查找后会得到两个元素，如果有两个主元素的话，那么这两个元素就是所要查找的，
    //如果只有一个主元素的话，那么还有一个是假的，所以在程序的最后还要再一次的遍历数组，看看最后得到的两个元素是否为
    //主元素
    vector<int> majorityElement(vector<int>& nums) {
        vector<int> result;
        //这里不能nums.size() <= 2，因为有可能出现类似于[2,2],此时应返回2，不能直接返回nums
        if(nums.size() <= 1)
            return nums;
        //假定主元素的下标
        int start1 = 0;
        int start2 = 1;
        int index = 0;
        //标记当前假定主元素的个数
        int count1 = 1;
        int count2 = 1;
        for(;start2<nums.size(); start2++){
            if(nums[start1] == nums[start2]){
                count1++;
                continue;
            }
            break;
        }
        for(index=start2+1;index<nums.size(); index++){
            if(nums[start1] == nums[index]){
                count1++;
                continue;
            }
            else if(nums[start2] == nums[index]){
                count2++;
                continue;
            }
            else{
                //如果假定的第一个主元素没有了，那么将当前的下标作为新的假定主元素
                if(count1 == 0){
                    start1 = index;
                    count1++;
                }
                //如果假定的第二个主元素没有了，那么将当前的下标作为新的假定主元素
                else if(count2 == 0){
                    start2 = index;
                    count2++;
                }
                //否则的话，当前元素与所假定的第一第二主元素不一样，三个为一组删除。
                else{
                    count1--;
                    count2--;
                }
                    
            }
            
        }
        count1 = 0;
        count2 = 0;
        if(start1<nums.size())
            for(int i=0; i<nums.size(); i++)
                if(nums[i] == nums[start1])
                    count1++;
        if(start2<nums.size())
            for(int i=0; i<nums.size(); i++)
                if(nums[i] == nums[start2])
                    count2++;
       
        if(count1>nums.size()/3)
            result.push_back(nums[start1]);
        if(count2>nums.size()/3)
            result.push_back(nums[start2]);
        return result;
    }
}


Summary Ranges 
Given a sorted integer array without duplicates, return the summary of its ranges.For example, given [0,1,2,4,5,7], return ["0->;2","4->;5","7"].
Credits:Special thanks to @jianchao.li.fighter for adding this problem and creating all test cases.

class Solution {
public:
    vector<string> summaryRanges(vector<int>& nums) {
        vector<string> result;
        if(nums.size() == 0)
            return result;
        int start = nums[0];
        int cur = nums[0];
        string temp = "";
        for(int i=1; i<nums.size(); i++){
            
            if(nums[i]-nums[i-1] == 1){
                
                continue;
            }
            temp = numToWord(start);
            if(start != nums[i-1]){
                temp += "->";
                temp += numToWord(nums[i-1]);
            }
            result.push_back(temp);
            start = nums[i];
        }
        temp = numToWord(start);
        if(start != nums[nums.size()-1]){
             temp += "->";
             temp += numToWord(nums[nums.size()-1]);
            
        }
        result.push_back(temp);
        return result;  
            
    }
    
    string numToWord(long long num){
        if(num == 0)
            return "0";
        string result = "";
        bool sign = false;
        if(num<0){
            sign = true;
            num = -num;
        }
        while(num != 0){
            result += (num%10 + '0');
            num = num/10;
        }
        string _result = "";
        for(int j=result.size()-1; j>=0; j--)
            _result+=result[j];
        
        return sign?'-'+_result:_result;
    }
}


Contains Duplicate II 
Given an array of integers and an integer k, find out whether there are two distinct indices i and j in the array such that nums[i] = nums[j] and the difference between i and j is at most k.


class Solution {
public:
    bool containsNearbyDuplicate(vector<int>& nums, int k) {
        if(nums.size()<=1 || k == 0)
            return false;
        for(int i=0; i<nums.size(); i++){
            if(hashMap.find(nums[i]) == hashMap.end()){
                hashMap[nums[i]] = i;
                
            }
            else{
                if(i-hashMap[nums[i]] <= k)
                    return true;
                else
                    hashMap[nums[i]] = i;
            }
        }
        return false;
    }

private:
    map<int, int> hashMap;
}


Contains Duplicate 
Given an array of integers, find if the array contains any duplicates. Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct.

class Solution {
public:
    bool containsDuplicate(vector<int>& nums) {
        if(nums.size()<=1)
            return false;
        for(int i=0; i<nums.size(); i++){
            if(hashMap.find(nums[i]) == hashMap.end())
                hashMap[nums[i]] = 1;
            else
                return true;
        }
        return false;
    }
    
private:
    map<int, int> hashMap;
}


Combination Sum III 
Find all possible combinations of k numbers that add up to a number n, given that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers.Ensure that numbers within the set are sorted in ascending order. Example 1:Input:  k = 3,  n = 7Output: [[1,2,4]] Example 2:Input:  k = 3,  n = 9Output: [[1,2,6], [1,3,5], [2,3,4]]
Credits:Special thanks to @mithmatt for adding this problem and creating all test cases.

class Solution {
public:
    //采用递归的方式
    vector<vector<int>> combinationSum3(int k, int n) {
        vector<vector<int> > ret;
        if(k == 0 || n == 0)
            return ret;
        vector<int> temp;
        _combinationSum3(ret, temp, 1, n, k);
        return ret;
        
    }
    
    void _combinationSum3(vector<vector<int> > &ret, vector<int> &temp, int start, int n, int k){
        if(n == 0 && k == 0){
            ret.push_back(temp);
            return;
        }
        if(start <=9 && start == n && k == 1){
            temp.push_back(start);
            ret.push_back(temp);
            temp.pop_back();
            return;
        }
        for(int i=start; i<=9; i++){
            if(i>n || k<=0)
                break;
            temp.push_back(i);
            _combinationSum3(ret, temp, i+1, n-i, k-1);
            temp.pop_back();
        }
            
    }
}


Minimum Size Subarray Sum 
Given an array of n positive integers and a positive integer s, find the minimal length of a subarray of which the sum ≥ s. If there isn't one, return 0 instead.For example, given the array [2,3,1,2,4,3] and s = 7,the subarray [4,3] has the minimal length under the problem constraint.click to show more practice.More practice:If you have figured out the O(n) solution, try coding another solution of which the time complexity is O(n log n).
Credits:Special thanks to @Freezen for adding this problem and creating all test cases.

class Solution {
public:
    //虽然不超时，但是运行时间比较慢,128ms
    /*
    int minSubArrayLen(int s, vector<int>& nums) {
        if(nums.size() == 0 || s == 0)
            return 0;
        
        return _minSubArrayLen(s, nums, 0);
        
    }
    
    int _minSubArrayLen(int s, vector<int>& nums, int start){
        int sum = 0;
        int length = 0;
        for(int i=start; i<nums.size(); i++){
            sum+=nums[i];
            length++;
            if(sum>=s)
                break;
                
        }
        int rest = 0;
        if(sum<s)
            return 0;
        rest = _minSubArrayLen(s, nums, start+1);
        if(rest == 0)
            return length;
        return length>rest? rest: length;
    }
    */
    // 4ms运行时间
    int minSubArrayLen(int s, vector<int>& nums) {

        if (nums.size() == 0) 
            return 0;

        int sumOfSubArr = nums[0];
        int start = 0;
        int result = nums.size();

        for (int i = 1; i<=nums.size(); i++) {
            while ((sumOfSubArr - nums[start]) >= s) {
                sumOfSubArr = sumOfSubArr - nums[start];
                start++;
            }    

            if (sumOfSubArr >= s && result > i - start) {
                 result = i - start;
            }

            if (i<nums.size()) {
                sumOfSubArr = sumOfSubArr + nums[i];
            }
        }
        return sumOfSubArr >= s ? result : 0;
    }

}


Rotate Array 
Rotate an array of n elements to the right by k steps.For example, with n = 7 and k = 3, the array [1,2,3,4,5,6,7] is rotated to [5,6,7,1,2,3,4]. 
Note:Try to come up as many solutions as you can, there are at least 3 different ways to solve this problem.[show hint]
Hint:Could you do it in-place with O(1) extra space?Related problem: Reverse Words in a String II
Credits:Special thanks to @Freezen for adding this problem and creating all test cases.

class Solution {
public:


    void rotate(vector<int>& nums, int k) {
        if(nums.size() == 0)
            return;
        int *temp = new int[nums.size()];
        k = k%nums.size();
        memcpy(temp, &nums[0]+(nums.size()-k), sizeof(int)*k);
        memcpy(temp+k, &nums[0], sizeof(int)*(nums.size()-k));
        memcpy(&nums[0], temp, nums.size()*sizeof(int));
        delete temp;
        
    }
}


Majority Element 
Given an array of size n, find the majority element. The majority element is the element that appears more than &amp;lfloor; n/2 &amp;rfloor; times.You may assume that the array is non-empty and the majority element always exist in the array.
Credits:Special thanks to @ts for adding this problem and creating all test cases.

class Solution {
public:
    //两个不同的元素抵消掉，最后剩下的就是那个众数
    int majorityElement(vector<int>& nums) {
        if(nums.size()==1)
            return nums[0];
        int count = 0;
        int start = 0; 
        int index = 1;
        for(; index<nums.size(); index++){
            if(nums[start] == nums[index]){
                count++;
                if(count>nums.size()/2)
                    return nums[start];
            }
                
            else{
                if(count == 0){
                    start = ++index;
                }
                else{
                    count--;
                }
            }
        }
         return nums[start];
    }
}


Find Peak Element 
A peak element is an element that is greater than its neighbors.Given an input array where num[i] ≠ num[i+1], find a peak element and return its index.The array may contain multiple peaks, in that case return the index to any one of the peaks is fine.You may imagine that num[-1] = num[n] = -∞.For example, in array [1, 2, 3, 1], 3 is a peak element and your function should return the index number 2.click to show spoilers.
Note:Your solution should be in logarithmic complexity.
Credits:Special thanks to @ts for adding this problem and creating all test cases.

class Solution {
public:
    //O(lgN)的空间复杂度
    int findPeakElement(vector<int>& nums) {
        if(nums.size() == 0 || nums.size() == 1)
            return 0;
        return findPeakElement(nums, 0, nums.size()-1);
        
    }
    //查找峰值的一个标记就是对于当前的元素，如果左边的元素更大，说明峰值在左边，否则的话就是在右边
    //这里要注意，所得到的mid有可能就是要求的下标，所以在进行下一个循环的时候吧，不能mid+1
    //或是mid-1！！！
    int findPeakElement(vector<int>& nums, int begin, int end){
        int mid = begin + (end-begin)/2;
        //结束条件，就是不能再进范围缩减了
        if(mid == begin || mid == end){
            return nums[begin]>nums[end]? begin: end;
        }
        
        if(nums[mid]>nums[mid+1]){
            return findPeakElement(nums, begin, mid);
        }
        return findPeakElement(nums, mid, end);
    }
}


Find Minimum in Rotated Sorted Array II 
Follow up for "Find Minimum in Rotated Sorted Array":What if duplicates are allowed?Would this affect the run-time complexity? How and why?Suppose a sorted array is rotated at some pivot unknown to you beforehand.(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).Find the minimum element.The array may contain duplicates.

class Solution {
public:
    int findMin(vector<int>& nums) {
        if(nums.size() == 0)
            return 0;
        if(nums.size() == 1)
            return nums[0];
        for(int i=1; i<nums.size(); i++){
            if(nums[i] < nums[i-1])
                return nums[i];
        }
        return nums[0];
    }
}


Find Minimum in Rotated Sorted Array 
Suppose a sorted array is rotated at some pivot unknown to you beforehand.(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).Find the minimum element.You may assume no duplicate exists in the array.

class Solution {
public:
    //每次取中间结点，如果中间的数小于right的数，说明最小值在左边，如果中间的数大于right的数，说明最小值在右边
    //O(logN)
    /*4ms
    int findMin(vector<int>& nums) {
        int left = 0;
        int right = nums.size()-1;
        while(left<right){
            int medium = left + (right-left)/2;
            //最小值在左边
            if(nums[medium]<nums[right])
                right = medium;
            else
                left = medium+1;
                
        }
        return nums[left];
    }
    */
    //也可以遍历，只要num[i]大于nums[i+1],就说明nums[i+1]为最小值
    //4ms
    int findMin(vector<int>& nums){
        for(int i =0; i<nums.size()-1; i++){
            if(nums[i]>nums[i+1])
                return nums[i+1];
        }
        return nums[0];
    }
}


Maximum Product Subarray 
Find the contiguous subarray within an array (containing at least one number) which has the largest product.For example, given the array [2,3,-2,4],the contiguous subarray [2,3] has the largest product = 6.

class Solution {
public:
    int maxProduct(vector<int>& nums) {
        int n = nums.size();
        if(n ==0 ) return 0;
        else if(n == 1) return nums[0];

        int posMax, negMax, maxim;
        posMax = max(0, nums[0]);
        negMax = min(0, nums[0]);
        maxim = posMax;

        for(int i=1; i<n; i++){
            if(nums[i] > 0){
                posMax = max(1, posMax)*nums[i];
                negMax = negMax*nums[i];
            }
            else if(nums[i] < 0){
                int negTemp = negMax;
                negMax = max(1, posMax)*nums[i];
                posMax = negTemp*nums[i];
            }
            else {
                posMax = 0;
                negMax = 0;
            }
            if(posMax > maxim) maxim = posMax;
        }

        return maxim;
    }
}


Longest Consecutive Sequence 
Given an unsorted array of integers, find the length of the longest consecutive elements sequence.For example,Given [100, 4, 200, 1, 3, 2],The longest consecutive elements sequence is [1, 2, 3, 4]. Return its length: 4.Your algorithm should run in O(n) complexity.

class Solution {
public:
    int longestConsecutive(vector<int>& nums) {
        if(nums.size() <= 1)
            return nums.size();
        unordered_set<int> numsSet(nums.begin(), nums.end());
        int length = 0;
        while(!numsSet.empty()){
            int k = *numsSet.begin();
            int temp = k;
            int len = 1;
            while(numsSet.find(++k) != numsSet.end()){
                len++;
                numsSet.erase(k);
            }
            k = temp;
            while(numsSet.find(--k) != numsSet.end()){
                len++;
                numsSet.erase(k);
            }
            
            if(length<len)
                length = len;
            numsSet.erase(temp);
            
        }
         return length;
    }
   
}


Word Ladder II 
Given two words (beginWord and endWord), and a dictionary's word list, find all shortest transformation sequence(s) from beginWord to endWord, such that:Only one letter can be changed at a timeEach intermediate word must exist in the word listFor example,Given:beginWord = "hit"endWord = "cog"wordList = ["hot","dot","dog","lot","log"]Return  [    ["hit","hot","dot","dog","cog"],    ["hit","hot","lot","log","cog"]  ]
Note:All words have the same length.All words contain only lowercase alphabetic characters.

class Solution {
public:
    /*
	//先找出最短的转换长度，再根据这个长度来计算可行的解，可以利用这个长度进行剪枝，这样可以减少不需要的空间和时间
	vector<vector<string>> findLadders(string beginWord, string endWord, unordered_set<string> &wordList) {
		if (beginWord == endWord)
			return{ { beginWord, endWord } };
		wordList.insert(endWord);
		int shortest = getShortestLength(beginWord, endWord, wordList);
		vector<vector<string>>ret;
		if (shortest == -1)
			return ret;
		unordered_set<string> visited;
		vector<string> temp;
		temp.push_back(beginWord);
		visited.insert(beginWord);
		findLadders(beginWord, endWord, wordList, visited, ret, temp, shortest-1);
		return ret;
	}

	//广搜
	int getShortestLength(string beginWord, string endWord, unordered_set<string> &wordList) {
		int length = 1;
		queue<string> cur;
		
		unordered_set<string> visited;
		cur.push(beginWord);
		visited.insert(beginWord);
		while (cur.size() != 0) {
			queue<string> next;
			while (cur.size() != 0) {
				string word = cur.front();
				cur.pop();
				for (int i = 0; i<word.length(); i++) {
					char wordi = word[i];
					for (int j = 0; j<26; j++) {
						word[i] = 'a' + j;
						if (word == endWord)
							return length + 1;
						if (wordList.count(word) != 0 && visited.count(word) == 0) {
							visited.insert(word);
							next.push(word);
						}
					}
					word[i] = wordi;
				}
			}
			length++;
			cur = next;
		}
		return -1;
	}
	//深搜找出所有可能解,超时！！！

	void findLadders(string beginWord, string endWord, unordered_set<string> &wordList, unordered_set<string> &visited, vector<vector<string>> &ret, vector<string>&temp, int length) {
		if (length == 0)
			return;
		
		for (int i = 0; i<beginWord.length(); i++) {
			char wordi = beginWord[i];
			vector<string> bt;
			for (int j = 0; j<26; j++) {
				beginWord[i] = 'a' + j;
				if (beginWord == endWord) {
					temp.push_back(beginWord);
					ret.push_back(temp);
					temp.pop_back();
					return;
				}
				if (wordList.count(beginWord) != 0 && visited.count(beginWord) == 0) {
					temp.push_back(beginWord);
					visited.insert(beginWord);
					bt.push_back(beginWord);
					findLadders(beginWord, endWord, wordList, visited, ret, temp, length - 1);
					temp.pop_back();
					//visited.erase(beginWord);
				}
			}
			for(int i=0; i<bt.size(); i++)
			    visited.erase(bt[i]);
			beginWord[i] = wordi;
		}
	}
	*/
	//与上一个不同的是这里直接的使用在广搜时所用的unordered_map<string, int> visited;在进行深搜的时候直接的利用
	//这其来对节点进行剪枝，也就是说深搜时，只搜索visited中的节点。visited中的int存储的是对应的word在广搜时所出现的
	//深度，如果在深搜的时候有对应的word出现在visited中但是其深度不是visited中的值的时候也可以对其进行剪枝处理
	/*TMD   还是超时啊！！！！
	vector<vector<string>> findLadders(string beginWord, string endWord, unordered_set<string> &wordList) {
		if (beginWord == endWord)
			return{ { beginWord, endWord } };
		wordList.insert(endWord);
		unordered_map<string, int> visited;
		int shortest = getShortestLength(beginWord, endWord, wordList, visited);
		vector<vector<string>>ret;
		if (shortest == -1)
			return ret;

		vector<string> temp;
		temp.push_back(beginWord);
		findLadders(beginWord, endWord, visited, ret, temp, shortest - 1, 2);
		return ret;
	}

	//广搜
	int getShortestLength(string beginWord, string endWord, unordered_set<string> &wordList, unordered_map<string, int> &visited) {
		int length = 1;
		queue<string> cur;
		cur.push(beginWord);
		visited[beginWord] = 1;
		while (cur.size() != 0) {
			queue<string> next;
			while (cur.size() != 0) {
				string word = cur.front();
				cur.pop();
				for (int i = 0; i<word.length(); i++) {
					char wordi = word[i];
					for (int j = 0; j<26; j++) {
						word[i] = 'a' + j;
						if (word == endWord)
							return length + 1;
						if (wordList.count(word) != 0 && visited.count(word) == 0) {
							visited[word] = length + 1;
							next.push(word);
						}
					}
					word[i] = wordi;
				}
			}
			length++;
			cur = next;
		}
		return -1;
	}
	//深搜找出所有可能解
	void findLadders(string beginWord, string endWord, unordered_map<string, int> &visited, vector<vector<string>> &ret, vector<string>&temp, int length, int deep) {
		if (deep - 1 > length)
			return;

		for (int i = 0; i<beginWord.length(); i++) {
			char wordi = beginWord[i];
			vector<string> bt;
			for (int j = 0; j<26; j++) {
				beginWord[i] = 'a' + j;
				if (beginWord == endWord) {
					temp.push_back(beginWord);
					ret.push_back(temp);
					temp.pop_back();
					return;
				}
				if (visited.count(beginWord) != 0 && visited[beginWord] == deep) {
					temp.push_back(beginWord);

					bt.push_back(beginWord);
					findLadders(beginWord, endWord,  visited, ret, temp, length, deep + 1);
					temp.pop_back();
					//visited.erase(beginWord);
				}
			}

			beginWord[i] = wordi;
		}
	}
	*/
	//另外一个思路，在广搜查找最短的转换路径长度时，记录每一个访问到的节点的前驱节点，这样的话
	//只需要从endWord节点开始，深搜其前驱节点知道beginWord为止，所有路径都是可行解，这样的深搜
	//完全没有冗余
    vector<vector<string>> findLadders(string beginWord, string endWord, unordered_set<string> &wordList) {
		if (beginWord == endWord)
			return{ { beginWord, endWord } };
		wordList.insert(endWord);
		unordered_map<string, vector<string>> preword;
		int shortest = getShortestLength(beginWord, endWord, wordList, preword);
		vector<vector<string>>ret;
		if (shortest == -1)
			return ret;

		vector<string> temp(shortest);
		temp[shortest-1] = endWord;
		findLadders(beginWord, endWord, ret, temp, preword, shortest-2);
		return ret;
	}

	//广搜
	int getShortestLength(string beginWord, string endWord, unordered_set<string> &wordList, unordered_map<string, vector<string>> &preword) {
		int length = 1;
		queue<string> cur;
		cur.push(beginWord);
		unordered_map<string, int> visited;
		visited[beginWord] = 1;
		int retlength = 0;
		bool getthelength = false;
		while (cur.size() != 0) {
			queue<string> next;
			while (cur.size() != 0) {
				string word = cur.front();
				string temp = word;
				cur.pop();
				getthelength = false;
				for (int i = 0; i<word.length(); i++) {
					char wordi = word[i];
					if(getthelength)
					    break;
					for (int j = 0; j<26; j++) {
						word[i] = 'a' + j;
						//为了得到endword的所有前驱word，在的到最短的长度后，还要继续遍历该层所剩下的其他word
						if (word == endWord) {
							preword[word].push_back(temp);
							retlength = length+1;
							getthelength = true;
							break;
						}

						if (wordList.count(word) != 0) {
							if (visited.count(word) == 0 || (visited.count(word) != 0 && visited[word] == length + 1))
								preword[word].push_back(temp);
							if (visited.count(word) == 0) {
								visited[word] = length + 1;
								next.push(word);
							}
						}
					}
					word[i] = wordi;
				}
			}
			if(retlength != 0)
			    return retlength;
			length++;
			cur = next;
		}
		return -1;
	}
	//深搜找出所有可能解
	void findLadders(string endWord, string word, vector<vector<string>> &ret, vector<string>&temp, unordered_map<string, vector<string>> &preword, int index) {
		if (word == endWord) {
			ret.push_back(temp);
			return;
		}
		vector<string> prevec = preword[word];
		for (int i = 0; i<prevec.size(); i++) {
			temp[index] = prevec[i];
			findLadders(endWord, prevec[i], ret, temp, preword, index-1);
 
		}

	}
}


Best Time to Buy and Sell Stock III 
Say you have an array for which the ith element is the price of a given stock on day i.Design an algorithm to find the maximum profit. You may complete at most two transactions.
Note:You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).

class Solution {
public:
    int maxProfit(vector<int>& prices) {
        if(prices.size() == 0)
            return 0;
        int *left = new int[prices.size()];
        int *right = new int[prices.size()];
        left[0] = 0;
        right[prices.size()-1] = 0;
        int smallest = prices[0];
        for(int i=1; i<prices.size(); i++){
            if(smallest>prices[i])
                smallest = prices[i];
            left[i] = prices[i]-smallest;
            if(left[i]<left[i-1])
                left[i] = left[i-1];
                
        }
        int largest = prices[prices.size()-1];
        for(int i=prices.size()-2; i>=0; i--){
            if(largest<prices[i])
                largest = prices[i];
            right[i] = largest-prices[i];
            if(right[i]<right[i+1])
                 right[i] = right[i+1];
        }
        int ret = INT_MIN;
        for(int i=0; i<prices.size(); i++){
            int temp = left[i]+right[i];
            if(ret<temp)
                ret = temp;
        }
        return ret;
    }
}


Best Time to Buy and Sell Stock II 
Say you have an array for which the ith element is the price of a given stock on day i.Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times). However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).

class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int profit = 0;
        for(int i=1; i<prices.size(); i++){
            if(prices[i]>prices[i-1])
                profit += (prices[i]-prices[i-1]);
        }
        return profit;
    }
}


Best Time to Buy and Sell Stock 
Say you have an array for which the ith element is the price of a given stock on day i.If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit.

class Solution {
public:
    int maxProfit(vector<int>& prices) {
        if(prices.size() == 0)
            return 0;
        int profit = 0;
        int smallest = prices[0];
        for(int i=1; i<prices.size(); i++){
            if(profit<prices[i]-smallest)
                profit = prices[i]-smallest;
            if(smallest>prices[i])
                smallest = prices[i];
        }
    return profit;
    }
}


Triangle 
Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below.For example, given the following triangle[     [2],    [3,4],   [6,5,7],  [4,1,8,3]]The minimum path sum from top to bottom is 11 (i.e., 2 + 3 + 5 + 1 = 11).
Note:Bonus point if you are able to do this using only O(n) extra space, where n is the total number of rows in the triangle.

class Solution {
public:  
    //直接的采用深度搜索会超时，这里跟树的遍历不一样，因为每一个节点只能遍历到其下一层的邻居节点，
    //也就是说同一层的相邻节点有一个共同的下层子节点，这也就是该问题的关键所在，可以根据该特点来
    //减少相同的遍历，从而提高速度。
    /*
    int minimumTotal(vector<vector<int>>& triangle) {
        if(triangle.size() == 0)
            return 0;
       
        int min = INT_MAX;
        minimumTotal(triangle, 1, 0, triangle[0][0], min);
        return min;
    }
    
    void minimumTotal(vector<vector<int> > &triangle, int row, int start, int sum, int &min){
        if(row == triangle.size()){
             if(min>sum)
               min = sum;
        }
        else{
            for(int i=start; i<=start+1; i++){
                minimumTotal(triangle, row+1, i, sum+triangle[row][i], min);
            }
        }
    }
    */
    //采用动态规划的方法
    int minimumTotal(vector<vector<int>>& triangle) {
        if(triangle.size() == 0)
            return 0;
       
        int *min = new int[triangle.size()];
        for(int i=0; i<triangle.size(); i++)
            min[i] = triangle[triangle.size()-1][i];
        for(int i=triangle.size()-2; i>=0; i--){
            int temp = min[i+1];
            for(int j=i; j>=0; j--){
                int val = triangle[i][j]+(temp>min[j]? min[j]:temp);
                temp = min[j];
                min[j] = val;
            }
               
        }
        return min[0];
    }
}


Pascal&#39;s Triangle II 
Given an index k, return the kth row of the Pascal's triangle.For example, given k = 3,Return [1,3,3,1].
Note:Could you optimize your algorithm to use only O(k) extra space?

class Solution {
public:
    vector<int> getRow(int rowIndex) {
        vector<int> row;
        for(int i=1; i<=rowIndex+1; i++){
            for(int j=i-2; j>0; j--){
                row[j] = row[j] + row[j-1];
            }
            row.push_back(1);
        }
        return row;
    }
}


Pascal&#39;s Triangle 
Given numRows, generate the first numRows of Pascal's triangle.For example, given numRows = 5,Return[     [1],    [1,1],   [1,2,1],  [1,3,3,1], [1,4,6,4,1]]

class Solution {
public:
    vector<vector<int>> generate(int numRows) {
        vector<vector<int> > result;
        vector<int> temp;
        for(int i=1; i<=numRows; i++){
            for(int j = i-2; j>0; j--){
                temp[j] = temp[j] + temp[j-1];
            }
            temp.push_back(1);
            result.push_back(temp);
        }
        return result;
    }
}


Construct Binary Tree from Inorder and Postorder Traversal 
Given inorder and postorder traversal of a tree, construct the binary tree.
Note:You may assume that duplicates do not exist in the tree.

/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {
        if(inorder.size() == 0 && postorder.size() == 0 || inorder.size() != postorder.size())
            return NULL;
        return buildTree(inorder, postorder, 0, inorder.size()-1, 0, postorder.size()-1);
    }
    
    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder, int instart, int inend, int poststart, int postend){
        if(instart > inend)
            return NULL;
        if(instart == inend)
            return new TreeNode(inorder[instart]);
        int index = instart;
        for(; index<=inend; index++)
            if(inorder[index] == postorder[postend])
                break;
        TreeNode *root = new TreeNode(inorder[index]);
        root->left = buildTree(inorder, postorder, instart, index-1, poststart, poststart+index-instart-1);
        root->right = buildTree(inorder, postorder, index+1, inend, poststart+index-instart, postend-1);
        
        return root;
    }
}


Construct Binary Tree from Preorder and Inorder Traversal 
Given preorder and inorder traversal of a tree, construct the binary tree.
Note:You may assume that duplicates do not exist in the tree.

/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        if(preorder.size() == 0 && inorder.size() == 0 || preorder.size() != inorder.size())
            return NULL;
        return buildTree(preorder, inorder, 0, preorder.size()-1, 0, inorder.size()-1);
    }
    
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder, int prestart, int preend, int instart, int inend){
        if(prestart > preend)
            return NULL;
        if(prestart == preend)
            return new TreeNode(preorder[prestart]);
        TreeNode* root = new TreeNode(preorder[prestart]);
        int index = instart;
        for(; index<=inend; index++)
            if(inorder[index] == preorder[prestart])
                break;
        root->left = buildTree(preorder, inorder, prestart+1, prestart+index-instart, instart, index-1);
        root->right = buildTree(preorder, inorder, prestart+index-instart+1, preend, index+1, inend);
        return root;
    }
}


Subsets II 
Given a collection of integers that might contain duplicates, nums, return all possible subsets.
Note:Elements in a subset must be in non-descending order.The solution set must not contain duplicate subsets.For example,If nums = [1,2,2], a solution is:[  [2],  [1],  [1,2,2],  [2,2],  [1,2],  []]

class Solution {
public:
    //这道题总体的算法与没有出现重复的题目是一样的，只不过在出现重复的元素的时候
    //对于重复的元素，只能往前选择格式，而不能跳着选
    //例如：对于1,2,2,2,2,3,4     在选择2的时候，有五种选法，0到4个2，如果选一个2，
    //那么只能选择第一个，选两个2只能选择前面的两个，以此类推，不能在前面有没有选择
    //的2出现的情况下，选择后面的2
    vector<vector<int>> subsetsWithDup(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        vector<vector<int>> ret;
        vector<int> temp;
        subsetsWithDup(ret, nums, 0, temp);
        return ret;
    }
    
    void subsetsWithDup(vector<vector<int>> &ret, vector<int> &nums, int start, vector<int> &temp){
        if(start == nums.size()){
            ret.push_back(temp);
            return ;
        }
        if(start == nums.size()-1 || nums[start] != nums[start+1]){
            subsetsWithDup(ret, nums, start+1, temp);
            temp.push_back(nums[start]);
            subsetsWithDup(ret, nums, start+1, temp);
            temp.pop_back();
        }
        else{
            //对于出现重复的元素，只能按顺序选择个数，不能跳着选择
            int index = start+1;
            while(index<nums.size() && nums[index] == nums[start]) index++;
            for(int i = 0; i<=index-start; i++){
                subsetsWithDup(ret, nums, index, temp);
                temp.push_back(nums[start]);
            }
            for(int i=0; i<=index-start; i++)
               temp.pop_back();
        }
    }
}


Merge Sorted Array 
Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array.
Note:You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2. The number of elements initialized in nums1 and nums2 are m and n respectively.

class Solution {
public:
    //先将nums1后移n个单位，然后在合并排序nums1和nums2，这样就可以在nums1的空间上实归排序
    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
        for(int i=m-1; i>=0; i--){
            nums1[i+n] = nums1[i];
        }
        int nums1Index = n;
        int nums2Index = 0;
        int index = 0;
        while(nums1Index<m+n && nums2Index<n){
            if(nums1[nums1Index] <= nums2[nums2Index]){
                nums1[index++] = nums1[nums1Index++];
            }
            else{
                nums1[index++] = nums2[nums2Index++];
            }
                
        }
        if(nums1Index == m+n){
            for(; nums2Index<n; nums2Index++)
                nums1[index++] = nums2[nums2Index];
        }
    }
}


Maximal Rectangle 
Given a 2D binary matrix filled with 0's and 1's, find the largest rectangle containing all ones and return its area.

class Solution {
public:
    /*
    //直接的以每一个元素作为长方形的左上角，以改点作为起始点，计算长方形的最大的面积
    //92ms
    int maximalRectangle(vector<vector<char>>& matrix) {
        if(matrix.size() == 0 || matrix[0].size() == 0)
            return 0;
        int largestarea = 0;
        int row = matrix.size();
        int col = matrix[0].size();
        for(int i=0; i<row; i++)
            for(int j=0; j<col; j++){
                int wide = INT_MAX;
                int starti = i;
                int area = 0;
                //计算以i，j为左上角的长方形的面积
                while(starti<row&&matrix[starti][j] == '1'){
                    int index = j;
                    while(index<col && matrix[starti][index]=='1')
                       index++;
                    if(wide>index-j)
                        wide = index-j;
                    starti++;
                    if(area<(starti-i)*wide)
                        area = (starti-i)*wide;
                }
                if(largestarea<area)
                    largestarea = area;
                
            }
         return largestarea;    
    }
    */
    
    //利用动态规划的思想，以及Largest Rectangle in Histogram的阶梯思路(需要O(N)空间以及O(N)的时间)
    //将矩阵每一行作为底，那么当前行上面的所有连续的为1的元素看成是一条柱形，直接的求每一行的最大长方形面积
    //就可以了,时间复杂度为O(M*N),空间也一样,不过空间还是可以在减少到O(N)的
    //28ms
    int maximalRectangle(vector<vector<char>>& matrix) {
        if(matrix.size() == 0 || matrix[0].size() == 0)
            return 0;
        int row = matrix.size();
		int col = matrix[0].size();
		int ret = 0;
		//记录每一行的连续的1的高度， 这里利用一点动态规划的思想
		vector<vector<int>> dp(row, vector<int>(col));
		//计算出以每一行为底部的柱形的高度
        for(int i=0; i<col; i++)
            dp[0][i] = matrix[0][i]=='1'? 1: 0;
        for(int i=1; i<row; i++){
            for(int j=0; j<col; j++){
                if(matrix[i][j] == '0')
                    dp[i][j] = 0;
                else
                    dp[i][j] = dp[i-1][j]+1;
            }
        }
        for(int i=0; i<row; i++){
            int area = getTheLargestRetangle(dp[i]);
            if(ret<area)
                ret = area;
        }
        return ret;
    }
    
    int getTheLargestRetangle(vector<int> &height){
        if(height.size() == 0)
            return 0;
        stack<int> stk;
        int maxarea = 0;
        int area = 0;
        for(int i=0; i<height.size(); i++){
            while(!stk.empty() && height[stk.top()]>height[i]){
                int index = stk.top();
                stk.pop();
                area = stk.empty()? i*height[index]: (i-stk.top()-1)*height[index];
                if(maxarea<area)
                    maxarea = area;
            }
            stk.push(i);
        }
       
        while(!stk.empty()){
            int index = stk.top();
            stk.pop();
            area = stk.empty()? height.size()*height[index]: (height.size()-stk.top()-1)*height[index];
            if(maxarea<area)
                maxarea = area;
        }
        
        return maxarea;
    }
    
}


Largest Rectangle in Histogram 
Given n non-negative integers representing the histogram's bar height where the width of each bar is 1, find the area of largest rectangle in the histogram.Above is a histogram where width of each bar is 1, given height = [2,1,5,6,2,3].The largest rectangle is shown in the shaded area, which has area = 10 unit.For example,Given heights = [2,1,5,6,2,3],return 10.

class Solution {
public:
    /*
    //找出每一个元素i的左边的最后一个小于等于该元素的下标n以及右边最后一个等于小于该元素的下标m，
    //那么以该元素作为顶边的长方形的面积为i*(m-n-1)
    int largestRectangleArea(vector<int>& height) {
        if(height.size() == 0)
            return 0;
        int *leftfirstless = new int[height.size()];
        int *rightfirstless = new int[height.size()];
        leftfirstless[0] = -1;
        rightfirstless[height.size()-1] = height.size();
        int ret = INT_MIN;
        //计算数组leftfirstless的值
        for(int i=1; i<height.size(); i++){
            if(height[i]>height[i-1])
                leftfirstless[i] = i-1;
            else{
                int index = leftfirstless[i-1];
                //是左边最后一个小于当前元素的值的下标，所以这里要 height[index]>=height[i]
                while(index != -1 && height[index]>=height[i]) index = leftfirstless[index];
                leftfirstless[i] = index;
            }
        }
        //计算数组rightfirstgrater的值
        for(int i=height.size()-2; i>=0; i--){
            if(height[i]>height[i+1])
                rightfirstless[i] = i+1;
            else{
                int index = rightfirstless[i+1];
                //是右边最后一个小于当前元素的值的下标，所以这里要 height[index]>=height[i]
                while(index != height.size() && height[index]>=height[i]) index = rightfirstless[index];
                rightfirstless[i] = index;
            }
        }
        for(int i=0; i<height.size(); i++){
            int area = height[i]*(rightfirstless[i]-leftfirstless[i]-1);
            if(ret<area)
                ret = area;
        }
        return ret;
    } 
    */
    
    //另外一种解法，使用stack
    //思想：将每一个柱形作为长方形的左边，对于当前的柱形，看看其最右边的是哪一个柱形，规则是，如果右边的柱形的
    //高度比当前的柱形的高度大，说明可以与右边合成更大的长方形，将右边的柱形入栈，继续遍历；如果右边的柱形的高比
    //当前的小，那么当前的柱形不能与右边的所有其他柱形形成长方形，这样的话，当前的柱形形成的长方形为其自己，当前的
    //柱形出栈，对新的栈顶元素进行同样的比较，如果新的元素的高度大于右边的柱形的高度，那么新的柱形可以跟刚出栈的
    //柱形形成长方形，高度新元素的值，以这种方式一直遍历下去。要注意，在遍历完成后，栈里面的内容有可能不为空，此时
    //里面的每一个柱形都可以与数组中最右边的柱形形成长方形
    int largestRectangleArea(vector<int>& height) {
        if(height.size() == 0)
            return 0;
        stack<int> stk;
        int maxarea = 0;
        int area = 0;
        for(int i=0; i<height.size(); i++){
            while(!stk.empty() && height[stk.top()]>height[i]){
                int index = stk.top();
                stk.pop();
                //这里需要注意，如果栈为空，说明当前的元素是目前的最小元素，所以可以以数组0和i-1作为长方形的左右边
                //长度为i，所以为i*height[index]， 如果不是为空，那栈顶的第一个元素为当前元素的前面数组中第一个小的下标，
                //设为j，那么当前的元素可以形成的长方形为j+1到i-1，长度i-stk.top()-1
                area = stk.empty()? i*height[index]: (i-stk.top()-1)*height[index];
                if(maxarea<area)
                    maxarea = area;
            }
            stk.push(i);
        }
        while(!stk.empty()){
            int index = stk.top();
            stk.pop();
            //如栈为空，那么当前的元素是数组里面最小的元素，形成的长方形的长度可以为height.size(), 否则的话，跟上面
            //的栈不为空的情况一样
            area = stk.empty()?height.size()*height[index]: (height.size()-stk.top()-1)*height[index];
            if(maxarea<area)
                maxarea = area;
        }
        return maxarea;
    }
    
}


Search in Rotated Sorted Array II 
Follow up for "Search in Rotated Sorted Array":What if duplicates are allowed?Would this affect the run-time complexity? How and why?Write a function to determine if a given target is in the array.

class Solution {
public:

   //因为数组里面有多个相同的元素，所以在判断轴点的medium的左右边的时候麻烦了很多，
   //对于3,1,1\ 1,1,3,1\1,3,1,1,1等情况一般都没有考虑到，这里要特别的考虑相等的情况
    bool search(vector<int>& nums, int target) {
        if(nums.size() == 0)
            return false;
        int left = 0;
        int right = nums.size()-1;
        while(left < right){
            int medium = left + (right-left)/2;
            if(nums[medium] == target)
                return true;
            //轴点在medium的右边
            if(nums[medium]>nums[right] ){
                if(nums[medium]>target && target>=nums[left])
                    right = medium-1;
                else
                    left = medium+1;
            }
            else if(nums[medium]<nums[right]){
                if(nums[medium]<target && target<=nums[right])
                    left = medium+1;
                else
                    right = medium-1;
            }
            //判断相等的情况,要特别的考虑相等的情况
            else{
                int i = medium+1;
                while(i<right && nums[i] == nums[right]) i++;
                if(i == right)
                    right = medium-1;
                else
                    left = medium+1;
                        
            }
        }
        
        return nums[left] == target;
    }
}


Remove Duplicates from Sorted Array II 
Follow up for "Remove Duplicates":What if duplicates are allowed at most twice?For example,Given sorted array nums = [1,1,1,2,2,3],Your function should return length = 5, with the first five elements of nums being 1, 1, 2, 2 and 3. It doesn't matter what you leave beyond the new length.

class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        if(nums.size() == 0)
            return 0;
        int length = 1;
        int index = 0;
        for(int i=1; i<nums.size(); i++){
            if(nums[i] != nums[index]){
                length++;
                nums[++index] = nums[i];
                continue;
            }
            length++;
            nums[++index] = nums[i];
            while(i<nums.size() && nums[++i] == nums[index]);
            if(i == nums.size())
                return length;
            length++;
            nums[++index] = nums[i];
        }
        return length;
    }
}


Word Search 
Given a 2D board and a word, find if the word exists in the grid.The word can be constructed from letters of sequentially adjacent cell, where "adjacent" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.For example,Given board = [  ['A','B','C','E'],  ['S','F','C','S'],  ['A','D','E','E']]word = "ABCCED", ->; returns true,word = "SEE", ->; returns true,word = "ABCB", ->; returns false.

class Solution {
public:
    //深搜
    bool exist(vector<vector<char>>& board, string word) {
        if(board.size() == 0 || board[0].size() == 0 || word.length() == 0)
            return false;
        vector<int> starts;
        for(int i=0; i<board.size(); i++){
            for(int j=0; j<board[0].size(); j++){
                if(board[i][j] == word[0]){
                    starts.push_back(i);
                    starts.push_back(j);
                }
            }
        }
        for(int i=0; i<starts.size(); i=i+2){
            int row = starts[i];
            int col = starts[i+1];
            if(exist(board, word, row, col))
                return true;
        }
        return false;
    }
    
    bool exist(vector<vector<char>>& board, string word, int row, int col){
        if(word.length() == 1 && 0<=row && row<board.size() && 0<=col && col<board[0].size())
            return true;
        //找出当前节点四个邻居是否可以遍历
        if(row-1 >= 0 && board[row-1][col] == word[1]){
            board[row][col] = '.';
            if(exist(board, word.substr(1, word.length()-1), row-1, col)){
                board[row][col] = word[0];
                return true;
            }
            board[row][col] = word[0];
        }
        if(row+1 < board.size() && board[row+1][col] == word[1]){
            board[row][col] = '.';
            if(exist(board, word.substr(1, word.length()-1), row+1, col)){
                board[row][col] = word[0];
                return true;
            }
            board[row][col] = word[0];
        }
        if(col-1 >= 0 && board[row][col-1] == word[1]){
            board[row][col] = '.';
            if(exist(board, word.substr(1, word.length()-1), row, col-1)){
                board[row][col] = word[0];
                return true;
            }
            board[row][col] = word[0];
        }
        if(col+1 < board[0].size() && board[row][col+1] == word[1]){
            board[row][col] = '.';
            if(exist(board, word.substr(1, word.length()-1), row, col+1)){
                board[row][col] = word[0];
                return true;
            }
            board[row][col] = word[0];
        }
        return false;
    }
}


Subsets 
Given a set of distinct integers, nums, return all possible subsets.
Note:Elements in a subset must be in non-descending order.The solution set must not contain duplicate subsets.For example,If nums = [1,2,3], a solution is:[  [3],  [1],  [2],  [1,2,3],  [1,3],  [2,3],  [1,2],  []]

class Solution {
public:
   //递归，8ms
   /*
    vector<vector<int>> subsets(vector<int>& nums) {
        if(nums.size() == 0)
            return {};
        vector<vector<int> > ret;
        vector<int> temp;
        sort(nums.begin(), nums.end());
        _subsets(ret, temp, nums, 0);
        return ret;
    }
    void _subsets(vector<vector<int> > &ret, vector<int> &temp, vector<int> &nums, int index){
        if(index == nums.size())
            ret.push_back(temp);
        else{
            _subsets(ret, temp, nums, index+1);
            
            temp.push_back(nums[index]);
            _subsets(ret, temp, nums, index+1);
            temp.pop_back();
        }
    }
    */
    //非递归方式 4ms
    vector<vector<int>> subsets(vector<int>& nums) {
        sort(nums.begin(),nums.end());

        vector<int> s;
        vector<vector<int>> result(1,s);
        int n = nums.size(),j;

        for(int i = 0 ; i+1<1<<n;i++)
        {
            for(j = 0; (i>>j)&1;j++) s.pop_back();
            s.push_back(nums[n - j - 1]);
            result.push_back(s);
        }

        return result;
    }
}


Sort Colors 
Given an array with n objects colored red, white or blue, sort them so that objects of the same color are adjacent, with the colors in the order red, white and blue.Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.
Note:You are not suppose to use the library's sort function for this problem.click to show follow up.Follow up:A rather straight forward solution is a two-pass algorithm using counting sort.First, iterate the array counting number of 0's, 1's, and 2's, then overwrite array with total number of 0's, then 1's and followed by 2's.Could you come up with an one-pass algorithm using only constant space?

class Solution {
public:
    //采用计算排除，因为这里只有三个不同的元素，所以可以直接的采用计算排序，
    //先算出每一个元素的出现次数，再从最小的元素开始每一个元素出现几次就写几次
    //这里就不写计算排序算法的实现了，这里采用的是:
    //
    //因为最后的结果是0在最前面，2在最后面，所以记住1的其实位置以及2的其实位置，每次遇到0，那么直接将0
    //与1的其实位置交换，1的起始位置右移，遇到1直接跳过，遇到2将2与2的其实位置的的前一个位置交换，此时要判断该位置的
    //值是否为0，是的话，采取0与1交换的方法，如果是1的话，直接跳过
    void sortColors(vector<int>& nums) {
        if(nums.size() == 0)
            return ;
        int index1 = -1;
        int index2 = nums.size()-1;
        while(index2>0 && nums[index2] == 2)index2--;
        if(index2 == -1)
            return ;
        index2++;
        //i<index2,因为到2的起始位置的时候，后面都已经是2了，没必要遍历了
        for(int i=0; i<index2; i++){
            //元素为1，直接跳过
            if(nums[i] == 1){
                if(index1 == -1)
                   index1 = i;
                continue;
            }
                
            //0与1交换
            if(nums[i] == 0 && index1 != -1){
                nums[index1] = 0;
                nums[i] = 1;
                index1++;
                continue;
            }
            //元素为2时，交换
            if(nums[i] == 2){
                nums[i] = nums[index2-1];
                nums[index2-1] = 2;
                index2--;
                if(nums[i] == 1 && index1 == -1)
                    index1 = i;
                else if(nums[i] == 0 && index1 != -1){
                    nums[index1] = 0;
                    nums[i] = 1;
                    index1++;
                }
                //这一步很关键，因为2的起始位置的前一位换成了2，有可能前一位的前一位以及其前面的元素是2，所以这里要遍历
                //一下，保证index2是最新的2的起始位置
                while(nums[index2] == 2)index2--;
                index2++;
            }
        }
    }
}


Search a 2D Matrix 
Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:Integers in each row are sorted from left to right.The first integer of each row is greater than the last integer of the previous row.For example,Consider the following matrix:[  [1,   3,  5,  7],  [10, 11, 16, 20],  [23, 30, 34, 50]]Given target = 3, return true.

class Solution {
public:
    //有两种方法：
    //1：每一次以右上角的元素作为比较值，比其大的，说明target不在最上面一行，递归查找剩下的矩阵，
    //   比其小的，说明不在最右边一列，递归查找剩下的矩阵
    //2：二分查找，先找出有可能在哪一行，再根据该行采用二分法继续查找
    //采用第二中方法
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        if(matrix.size() == 0)
            return false;
        int line = 0;
        //先二分定位行
        int top = 0;
        int bottom = matrix.size()-1;
        while(top<bottom-1){
            int medium = (top+bottom)/2;
            if(matrix[medium][0] == target)
                return true;
            if(matrix[medium][0] > target)
                bottom = medium-1;
            else
                top = medium;
        }
        if(matrix[bottom][0] <= target)
            line = bottom;
        else
            line = top;
        //在特定行中二分查找
        int left = 0;
        int right = matrix[line].size()-1;
        while(left<right){
            int medium = (left+right)/2;
            if(matrix[line][medium] == target)
                return true;
            if(matrix[line][medium]>target)
                right = medium-1;
            else
                left = medium+1;
        }
        return matrix[line][left] == target;
    }
}


Set Matrix Zeroes 
Given a m x n matrix, if an element is 0, set its entire row and column to 0. Do it in place.click to show follow up.Follow up:Did you use extra space?A straight forward solution using O(mn) space is probably a bad idea.A simple improvement uses O(m + n) space, but still not the best solution.Could you devise a constant space solution?

class Solution {
public:
    //第一行作为列是否为0的标记，第一列作为行是否为0的标记，rowzero标记第一行是否为0，colzero标记第一列是否为0
    void setZeroes(vector<vector<int>>& matrix) {
         int row = matrix.size();
         int col = matrix[0].size();
         bool rowzero = false;
         bool colzero = false;
         for(int i=0; i<col; i++)
             if(matrix[0][i] == 0){
                 rowzero = true;
                 break;
             }
         for(int i=0; i<row; i++)
             if(matrix[i][0] == 0){
                 colzero = true;
                 break;
             }
         for(int i=1; i<row; i++)
             for(int j=1; j<col; j++){
                 if(matrix[i][j] == 0){
                     matrix[i][0] = 0;
                     matrix[0][j] = 0;
                 }
             }
        for(int i=1; i<col; i++){
            if(matrix[0][i] == 0){
                for(int j=1; j<row; j++)
                    matrix[j][i] = 0;
            }
        }
        
        for(int i=0; i<row; i++){
            if(matrix[i][0] == 0)
                for(int j=1; j<col; j++)
                    matrix[i][j] = 0;
        }
        if(rowzero)
            for(int i=0; i<col; i++)
                matrix[0][i] = 0;
        if(colzero)
            for(int i=0; i<row; i++)
                matrix[i][0] = 0;
    }
}


Plus One 
Given a non-negative number represented as an array of digits, plus one to the number.The digits are stored such that the most significant digit is at the head of the list.

class Solution {
public:
    vector<int> plusOne(vector<int>& digits) {
        vector<int> result;
        if(digits.size() == 0){
            result.push_back(1);
            return result;
        }
        int carry = 1;
        for(int i=digits.size()-1; i>=0; i--){
            carry = carry + digits[i];
            result.push_back(carry%10);
            carry /= 10;
        }
        if(carry != 0)
            result.push_back(carry);
            
        reverse(result.begin(), result.end());
        return result;
    }
}


Minimum Path Sum 
Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path.
Note: You can only move either down or right at any point in time.

class Solution {
public:

    //递归会超时！！！
    /*
    int minPathSum(vector<vector<int>>& grid) {
        if(grid.size() == 0)
            return 0;
        return _minPathSum(grid, 0, 0);
    }
    int _minPathSum(vector<vector<int>>& grid, int i, int j){
        if(i== grid.size() || j == grid[0].size())
            return INT_MAX;
        if(i== grid.size()-1 && j == grid[0].size()-1)
            return grid[i][j];
        int down  = _minPathSum(grid, i+1, j);
        int right = _minPathSum(grid, i, j+1);
        return down<right? grid[i][j]+down: grid[i][j]+right;
    }
    */
    
    
    //加备忘录
    /*
    int minPathSum(vector<vector<int>>& grid) {
        if(grid.size() == 0)
            return 0;
        int row = grid.size();
        int col = grid[0].size();
        int **f = new int*[row+1];
        for(int i=0; i<=row; i++)
            f[i] = new int[col+1];
        for(int i=0; i<=row; i++)
            for(int j=0; j<=col; j++)
                f[i][j] = -1;
        return _minPathSum(grid, 0, 0, f);
    }
    
    int _minPathSum(vector<vector<int>>& grid, int i, int j, int **f){
        if(i== grid.size() || j == grid[0].size())
            return INT_MAX;
        if(i== grid.size()-1 && j == grid[0].size()-1)
            return grid[i][j];
        
        int down;
        if(f[i+1][j] == -1){
            down = _minPathSum(grid, i+1, j, f);
            f[i+1][j] = down;
        }
        else
            down = f[i+1][j];
            
        int right;
        if(f[i][j+1] == -1){
            right = _minPathSum(grid, i, j+1, f);
            f[i][j+1] = right;
        }
        else
            right = f[i][j+1];
        
        return down<right? grid[i][j]+down: grid[i][j]+right;
    }
    */
    
    //动态规划+滚动数组
    int minPathSum(vector<vector<int>>& grid) {
        if(grid.size() == 0)
            return 0;
        int row = grid.size();
        int col = grid[0].size();
        int *f = new int[col];
        for(int i=0; i<col-1; i++)
            f[i] = INT_MAX;
        f[col-1] = 0;
        for(int i=row-1; i>=0; i--)
            for(int j=col-1; j>=0; j--){
                if(j == col-1)
                    f[j] += grid[i][j];
                else{
                    f[j] = f[j]>f[j+1]? f[j+1]+grid[i][j]: grid[i][j]+f[j];
                }
            }
        return f[0];     
        
    }
}


Unique Paths II 
Follow up for "Unique Paths":Now consider if some obstacles are added to the grids. How many unique paths would there be?An obstacle and empty space is marked as 1 and 0 respectively in the grid.For example,There is one obstacle in the middle of a 3x3 grid as illustrated below.[  [0,0,0],  [0,1,0],  [0,0,0]]The total number of unique paths is 2.
Note: m and n will be at most 100.

class Solution {
public:
    //直接的动态+滚动数组
    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
        if(obstacleGrid.size() == 0)
            return 0;
        int m = obstacleGrid.size();
        int n = obstacleGrid[0].size();
        int *f = new int[n+1];
        
        for(int i=n; i>=0; i--)
            f[i] = 0;
        f[n-1] = obstacleGrid[m-1][n-1] == 1? 0: 1;
        for(int i=m-1; i>=0; i--)
            for(int j=n-1; j>=0; j--){
                if(i == m-1 && j == n-1)
                    continue;
                if(obstacleGrid[i][j] == 1)
                    f[j] = 0;
                else{
                    f[j] = f[j] + f[j+1];
                }
            }
        return f[0];
    }
}


Unique Paths 
A robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below).The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below).How many possible unique paths are there?Above is a 3 x 7 grid. How many possible unique paths are there?
Note: m and n will be at most 100.

class Solution {
public:
    //可以直接的使用排列组合的公式：C(m-1, m-1+n-1)来计算结果的数量，但是m和n的值有可能是100， 结果会出现溢出，所以
    //还是不能直接的使用数学公式
    //直接的递归会超时！！！
    //加备忘录
    /*
    int uniquePaths(int m, int n) {
        if(m == 1 || n == 1)
            return 1;
        int **f = new int*[m];
        for(int i=0; i<m; i++)
            f[i] = new int[n];
        for(int i=0; i<m; i++)
            for(int j=0; j<n; j++)
                f[i][j] = -1;
        for(int i=0; i<n; i++)
            f[m-1][i] = 1;
        for(int i=0; i<m; i++)
            f[i][n-1] = 1;
            
        _uniquePath(m, n, 0, 0, f);
        return f[0][0];
    }
    
    void _uniquePath(int m, int n, int startrow, int startcol, int **f){
        if(f[startrow][startcol] != -1)
            return ;
        if(f[startrow][startcol+1] == -1)
           _uniquePath(m, n, startrow, startcol+1, f);
        if(f[startrow+1][startcol] == -1)
           _uniquePath(m, n, startrow+1, startcol, f);
        f[startrow][startcol] = f[startrow][startcol+1]+f[startrow+1][startcol];
            
    }
    */
    
    //使用动态规划+滚动数组
    int uniquePaths(int m, int n) {
        if(m == 1 || n == 1)
            return 1;
        int *f = new int[n];
        for(int i=0; i<n; i++)
            f[i] = 1;
        for(int i=0; i<m-1; i++)
            for(int j=n-2; j>=0; j--)
                f[j] = f[j] + f[j+1];
        return f[0];

    }
}


Spiral Matrix II 
Given an integer n, generate a square matrix filled with elements from 1 to n2 in spiral order.For example,Given n = 3,You should return the following matrix:[ [ 1, 2, 3 ], [ 8, 9, 4 ], [ 7, 6, 5 ]]

class Solution {
public:
    vector<vector<int>> generateMatrix(int n) {
        vector<vector<int> > ret;
        for(int i=0; i<n; i++){
            vector<int> temp(n, 0);
            ret.push_back(temp);
        }
        
        int startrow=0;
        int startcol = 0;
        int num = 1;
        while(startrow<n){
            for(int i=startcol; i<n; i++){
                ret[startrow][i] = num++;
            }
            for(int i=startrow+1; i<n; i++)
                ret[i][n-1] = num++;
            for(int i=n-2; i>=startcol; i--)
                ret[n-1][i] = num++;
            for(int i=n-2; i>startrow; i--)
                ret[i][startcol] = num++;
            startrow++;
            startcol++;
            n--;
        }
        return ret;
    }
}


Insert Interval 
Given a set of non-overlapping intervals, insert a new interval into the intervals (merge if necessary).You may assume that the intervals were initially sorted according to their start times.Example 1:Given intervals [1,3],[6,9], insert and merge [2,5] in as [1,5],[6,9].Example 2:Given [1,2],[3,5],[6,7],[8,10],[12,16], insert and merge [4,9] in as [1,2],[3,10],[12,16].This is because the new interval [4,9] overlaps with [3,5],[6,7],[8,10].

/**
 * Definition for an interval.
 * struct Interval {
 *     int start;
 *     int end;
 *     Interval() : start(0), end(0) {}
 *     Interval(int s, int e) : start(s), end(e) {}
 * };
 */
class Solution {
public:
    vector<Interval> insert(vector<Interval>& intervals, Interval newInterval) {
        vector<Interval> ret;
        if(intervals.size() == 0){
            ret.push_back(newInterval);
            return ret;
        }
            
        int i=0;
        while(i<intervals.size() && intervals[i].end<newInterval.start){
            ret.push_back(intervals[i]);
            i++;
        }
        if(i == intervals.size()){
            ret.push_back(newInterval);
            return ret;
        }
        if(intervals[i].start<=newInterval.start)
            newInterval.start = intervals[i].start;
        if(newInterval.end<intervals[i].start){
            ret.push_back(newInterval);
            ret.push_back(intervals[i]);
        }
            
        else if(newInterval.end<=intervals[i].end){
            newInterval.end = intervals[i].end;
            ret.push_back(newInterval);
        }
        else{
            i++;
            while(i<intervals.size() && intervals[i].end<newInterval.end)
                i++;
            if(i==intervals.size()){
                ret.push_back(newInterval);
                return ret;
            }
            if(intervals[i].start<=newInterval.end){
                newInterval.end = intervals[i].end;
                ret.push_back(newInterval);
            }
            else{
                ret.push_back(newInterval);
                ret.push_back(intervals[i]);
            }
        }
        while(++i<intervals.size())
            ret.push_back(intervals[i]);
        return ret;
       
    }
}


Merge Intervals 
Given a collection of intervals, merge all overlapping intervals.For example,Given [1,3],[2,6],[8,10],[15,18],return [1,6],[8,10],[15,18].

/**
 * Definition for an interval.
 * struct Interval {
 *     int start;
 *     int end;
 *     Interval() : start(0), end(0) {}
 *     Interval(int s, int e) : start(s), end(e) {}
 * };
 */
class Solution {
public:
    vector<Interval> merge(vector<Interval>& intervals) {
        if(intervals.size() == 0)
            return {};
        sort(intervals.begin(), intervals.end(), cmp);
        vector<Interval> ret;
        Interval temp = intervals[0];
        for(int i=1; i<intervals.size(); i++){
            if(intervals[i].start<= temp.end){
                temp.end = intervals[i].end>temp.end? intervals[i].end: temp.end;
                continue;
            }
            ret.push_back(temp);
            temp = intervals[i];
        }
        ret.push_back(temp);
        return ret;
    }
    
    static bool cmp(Interval &a, Interval &b){
        return a.start<b.start;
    }
}


Jump Game 
Given an array of non-negative integers, you are initially positioned at the first index of the array.Each element in the array represents your maximum jump length at that position. Determine if you are able to reach the last index.For example:A = [2,3,1,1,4], return true.A = [3,2,1,0,4], return false.

class Solution {
public:
    //先从右到左遍历数组，找到第一个为0的元素的下标index，然后以改下标为起点继续向左遍历，看看前面
    //的元素跳跃步骤能不能跳过为0的下标，判断公式为：index-i<nums[i],可以跳过，否则不能跳过。
    //注意有一个bug：如果终点为0，那么此时是要跳到里面去，而不是要绕过他的
    //解决方法是：终点0不为0无所谓，因为最后跳进去时已经到达了，不需要再往前跳，所以算法应该找到排除终点数值影响的第一个0元素下标
    bool canJump(vector<int>& nums) {
        //从倒数第二个元素开始
        int index = nums.size()-2;
        while(index>=0){
             while(index>=0 && nums[index] > 0) index--;
            if(index == -1)
                return true;
            int i=index-1;
            
            for(; i>=0; i--){
                if(index-i < nums[i])
                    break;
            }
            if(i == -1)
                return false;
            index = i-1;
        }
       return true;
    }
}


Spiral Matrix 
Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order.For example,Given the following matrix:[ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ]]You should return [1,2,3,6,9,8,7,4,5].

class Solution {
public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        if(matrix.size() == 0)
            return {};

        int startrow = 0;
        int startcol = 0;
        int row = matrix.size();
        int col = matrix[0].size();
        vector<int> ret;
        while(startrow<row && startcol<col){
            //第一行
            for(int i=startcol; i<col; i++)
                ret.push_back(matrix[startrow][i]);
            //最右边列
            for(int i=startrow+1; i<row; i++)
                ret.push_back(matrix[i][col-1]);
            //最下面一行，从右到左
            //防止只有一行的情况，只有一行的时候，前面已经遍历好了
            if(startrow != row-1)
                for(int i=col-2; i>=startcol; i--)
                    ret.push_back(matrix[row-1][i]);
            //最左边一列，从下到上
            //防止只有一列的情况，只有一列的时候，最右边一列的时候已经遍历好了
            if(startcol != col-1)
                for(int i=row-2; i>startrow; i--)
                    ret.push_back(matrix[i][startcol]);
            startrow++;
            startcol++;
            row--;
            col--;
        }
        return ret;
    }
}


Maximum Subarray 
Find the contiguous subarray within an array (containing at least one number) which has the largest sum.For example, given the array [&amp;#8722;2,1,&amp;#8722;3,4,&amp;#8722;1,2,1,&amp;#8722;5,4],the contiguous subarray [4,&amp;#8722;1,2,1] has the largest sum = 6.click to show more practice.More practice:If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.

class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        if(nums.size() == 0)
            return 0;
        int largest = INT_MIN;
        int pre = -1;
        for(int i=0; i<nums.size(); i++){
            if(pre>0){
                pre += nums[i];
               
            }
            else{
                pre = nums[i];
            }
            if(largest<pre)
                largest = pre;
        }
        return largest;
    }
}


Rotate Image 
You are given an n x n 2D matrix representing an image.Rotate the image by 90 degrees (clockwise).Follow up:Could you do this in-place?

class Solution {
public:
    void rotate(vector<vector<int>>& matrix) {
        int n = matrix.size();
        int newi;
        int newj;
        int temp1;
        int temp2;
        for(int i=0; i<(matrix.size()+1)/2; i++)
            for(int j=i; j<matrix.size()-i-1; j++){
                temp1 = matrix[i][j];
                int i1 = i;
                int j1 = j;
                while(true){
                    newi = j1;
                    newj= n-i1-1;
                    temp2 = matrix[newi][newj];
                    matrix[newi][newj] = temp1;
                    temp1 = temp2;
                    if(newi == i && newj == j)
                        break;
                    i1 = newi;
                    j1 = newj;
                }
                  
            }
      
    }
}


Jump Game II 
Given an array of non-negative integers, you are initially positioned at the first index of the array.Each element in the array represents your maximum jump length at that position. Your goal is to reach the last index in the minimum number of jumps.For example:Given array A = [2,3,1,1,4]The minimum number of jumps to reach the last index is 2. (Jump 1 step from index 0 to 1, then 3 steps to the last index.)
Note:You can assume that you can always reach the last index.

class Solution {
public:
    //采用贪心的方法，对于当前的位置i，找出[i, i+nums[i]]中一个下标k，使得nums[k]+k的值在[i, nums[i]+i]中最大
    //那么下一步就直接的跳到位置k上，继续遍历
    int jump(vector<int>& nums) {
        if(nums.size() <= 1)
            return 0;
        int size = nums.size();
        int count = 0;
        for(int i=0; i<nums.size(); i++){
            //如果当前的位置可以直接的跳到终点，那么直接的跳到终点
            if(nums[i]+i >= size-1)
                return count+1;
            int largest = 0;
            int index = i;
            //找出[i, i+nums[i]]中一个下标k，使得nums[k]+k的值在[i, nums[i]+i]中最大
            for(int j=i; j<=nums[i]+i; j++){
                if(largest<nums[j]+j){
                    largest = nums[j]+j;
                    index = j;
                }
            }
            //跳到index上，count值加1
            count++;
            i = index-1;
        }
    }
}


Trapping Rain Water 
Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining. For example, Given [0,1,0,2,1,0,1,3,2,1,2,1], return 6.The above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. Thanks Marcos for contributing this image!

class Solution {
public:
    int trap(vector<int>& height) {
        if(height.size() <= 1)
            return 0;
        int *leftlargest = new int[height.size()];
        int *rightlargest = new int[height.size()];
        int largest = 0;
        int total = 0;
        for(int i=0; i<height.size(); i++){
            leftlargest[i] = largest;
            if(largest<height[i])
                largest = height[i];
        }
        largest = 0;
        for(int i=height.size()-1; i>=0; i--){
            rightlargest[i] = largest;
            if(largest<height[i])
                largest = height[i];
            
        }
        
        for(int i=1; i<height.size()-1; i++){
            int small = leftlargest[i]>rightlargest[i]? rightlargest[i]: leftlargest[i];
            if(small<=height[i])
                continue;
            total += (small-height[i]);
        }
        
        return total;
    }
}


First Missing Positive 
Given an unsorted integer array, find the first missing positive integer.For example,Given [1,2,0] return 3,and [3,4,-1,1] return 2.Your algorithm should run in O(n) time and uses constant space.

class Solution {
public:
    //采用桶排序的方法，每一个元素都应该放在自己所应该处的位置，如果没有对应的位置，那么忽略该元素
    //然后遍历以便数组，如果对应的小标i没有存放值i+1，那么i+1便是第一个所要找的元素
    int firstMissingPositive(vector<int>& nums) {
        if(nums.size() == 0)
            return 1;
        int size = nums.size();
        for(int i=0; i<nums.size(); i++){
            //为了防止数组冲出现相同的元素，在对当nums[i]所处的位置不对的时候，在放在其应该放的位置之前，要先检查该位置的值是否
            //已经是正确归放了的，如果是的话，直接忽略nums[i]
            //例如： [1,1],第二个1要忽略，否则的话会出现死循环
            while(nums[i]!=(i+1) && nums[i]>0 && nums[i]<=size && nums[nums[i]-1] != nums[i]){
                int temp = nums[nums[i]-1];
                nums[nums[i]-1] = nums[i];
                nums[i] = temp;
            }
        }
        int i=0;
        for(; i<nums.size(); i++){
            if(nums[i] != i+1)
                return i+1;
        }
        return i+1;
    }
}


Combination Sum II 
Given a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.Each number in C may only be used once in the combination.
Note:All numbers (including target) will be positive integers.Elements in a combination (a1, a2, … , ak) must be in non-descending order. (ie, a1 ≤ a2 ≤ … ≤ ak).The solution set must not contain duplicate combinations.For example, given candidate set 10,1,2,7,6,1,5 and target 8, A solution set is: [1, 7] [1, 2, 5] [2, 6] [1, 1, 6] 

class Solution {
public:
    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {
        if(candidates.size() == 0)
            return {};
        sort(candidates.begin(), candidates.end());
        vector<vector<int> > ret;
        vector<int> temp;
        _combinationSum2(candidates, target, ret, temp, 0);
        return ret;
    }
    
    void _combinationSum2(vector<int> &candidates, int target, vector<vector<int> > &ret, vector<int> temp, int start){
        if(target == 0){
            ret.push_back(temp);
            return;
        }
        for(int i=start; i<candidates.size(); i++){
            //在同一个循环中要去重
            if(i>start && candidates[i] == candidates[i-1])
                continue;
            if(candidates[i] > target)
                return;
            temp.push_back(candidates[i]);
            _combinationSum2(candidates, target-candidates[i], ret, temp, i+1);
            temp.pop_back();
        }
    }
}


Combination Sum 
Given a set of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T. The same repeated number may be chosen from C unlimited number of times.
Note:All numbers (including target) will be positive integers.Elements in a combination (a1, a2, … , ak) must be in non-descending order. (ie, a1 ≤ a2 ≤ … ≤ ak).The solution set must not contain duplicate combinations.For example, given candidate set 2,3,6,7 and target 7, A solution set is: [7] [2, 2, 3] 

class Solution {
public:
    //递归，遍历candidates,对于每一个元素，如果小于target的话，加进去，计入下一个循环，此循环从当前元素开始
    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        if(candidates.size() == 0)
            return {};
        vector<vector<int> > ret;
        vector<int> temp;
        sort(candidates.begin(), candidates.end());
        _combinationSum(candidates, target, 0, temp, ret);
        return ret;
    }
    
    void _combinationSum(vector<int> &candidates, int target, int start, vector<int>& temp, vector<vector<int> >& ret){
        if(target == 0){
            ret.push_back(temp);
            return ;
        }
        for(int i=start; i<candidates.size(); i++){
            if(candidates[i]<=target){
                temp.push_back(candidates[i]);
                _combinationSum(candidates, target-candidates[i], i, temp, ret);
                temp.pop_back();
            } 
            else
                return ;
        }
    }
}


Search Insert Position 
Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.You may assume no duplicates in the array.Here are few examples.[1,3,5,6], 5 &amp;#8594; 2[1,3,5,6], 2 &amp;#8594; 1[1,3,5,6], 7 &amp;#8594; 4[1,3,5,6], 0 &amp;#8594; 0

class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        if(nums.size() == 0)
            return 0;
        int left = 0;
        int right = nums.size()-1;
        while(left < right){
            int medium = left+(right-left)/2;
            if(nums[medium] == target)
                return medium;
            if(nums[medium]>target)
                right = medium-1;
            else{
                left = medium+1;
            }
        }
        if(nums[left] == target)
            return left;
        if(nums[left] <target)
            return left+1;
        return left;
    }
}


Search for a Range 
Given a sorted array of integers, find the starting and ending position of a given target value.Your algorithm's runtime complexity must be in the order of O(log n).If the target is not found in the array, return [-1, -1].For example,Given [5, 7, 7, 8, 8, 10] and target value 8,return [3, 4].

class Solution {
public:
    vector<int> searchRange(vector<int>& nums, int target) {
        if(nums.size() == 0)
            return {-1, -1};
        int left = 0;
        int right = nums.size()-1;
        int begin = -1;
        int end = -1;
        while(left < right){
            int medium = left + (right-left)/2;
            if(nums[medium] == target){
                if(medium == 0 || nums[medium-1] != target)
                    begin = medium;
                else
                    begin = getBegin(nums, target, left, medium-1);
                if(medium == nums.size()-1 || nums[medium+1] != target)
                    end = medium;
                else 
                    end = getEnd(nums, target, medium+1, right);
                 return {begin, end};   
            }
            if(nums[medium] < target)
                left = medium + 1;
            else
                right = medium - 1;
        }
        if(nums[left] == target){
            begin = left;
            end = left;
        }
        return {begin, end};
    }
    
    int getBegin(vector<int> &nums, int target, int start, int end){
        int left = start, right = end;
        while(left < right){
            int medium = left + (right-left)/2;
            if(nums[medium] == target){
                if(medium == 0 || nums[medium-1] != target)
                    return medium;
                else
                    return  getBegin(nums, target, left, medium-1);
            }
            if(nums[medium] < target)
                left = medium + 1;
            else
                right = medium - 1;
        }
        return  left;
    }
    
    int getEnd(vector<int> &nums, int target, int start, int end){
        int left = start, right = end;
        while(left < right){
            int medium = left + (right-left)/2;
            if(nums[medium] == target){
                if(medium == nums.size()-1 || nums[medium+1] != target)
                    return medium;
                else
                    return  getEnd(nums, target, medium+1, right);
            }
            if(nums[medium] < target)
                left = medium + 1;
            else
                right = medium - 1;
        }
        return  left;
    }
}


Search in Rotated Sorted Array 
Suppose a sorted array is rotated at some pivot unknown to you beforehand.(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).You are given a target value to search. If found in the array return its index, otherwise return -1.You may assume no duplicate exists in the array.

class Solution {
public:
    int search(vector<int>& nums, int target) {
        if(nums.size() == 0)
            return -1;
        if(nums.size() ==1 )
            return nums[0] == target? 0: -1;
        int left = 0, right = nums.size()-1;
        while(left < right-1){
            int medium = left + (right-left)/2;
            if(nums[medium] == target)
                return medium;
            if(nums[medium] < nums[right]){
                if(target <= nums[right] && target > nums[medium]){
                    left = medium+1;
                }
                else{
                    right = medium;
                }
            }
            else{
                if(target>nums[right] && target <nums[medium])
                    right = medium-1;
                else
                    left = medium;
            }
            
        }
        if(nums[left] == target)
            return left;
        if(nums[left+1] == target)
            return left+1;
        return -1;
    }
}


Next Permutation 
Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).The replacement must be in-place, do not allocate extra memory.Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.1,2,3 &amp;#8594; 1,3,23,2,1 &amp;#8594; 1,2,31,1,5 &amp;#8594; 1,5,1

class Solution {
public:
    void nextPermutation(vector<int>& nums) {
        if(nums.size() <= 1)
            return ;
        int size = nums.size();
        int i;
        for(i=size-2; i>=0; i--){
            if(nums[i]<nums[i+1])
                break;
            
        }
        if(i == -1){
            for(int j=0, k=size-1; j<k; j++, k--){
                int temp = nums[j];
                nums[j] = nums[k];
                nums[k] = temp;
            }
        }
        else{
            //找到i后面的元素中大于nums[i]的最小元素，然后和nums[i]进行交换
            int index = i+1;
            int diff = INT_MAX;
            for(int j=i+1; j<size; j++){
                //这里要<= diff，因为可能有相同的元素出现，此时要找出相同元素最后面的那一个
                //例如：输入[2,3,1,3,3]，   输出：[2,3,3,1,3]
                if(nums[j]>nums[i] && nums[j]-nums[i] <= diff){
                    diff = nums[j]-nums[i];
                    index = j;
                }
            }
            int temp = nums[i];
            nums[i] = nums[index];
            nums[index] = temp;
            for(int j=i+1, k=size-1; j<k; j++, k--){
                int temp = nums[j];
                nums[j] = nums[k];
                nums[k] = temp;
            }
        }
    }
}


Remove Element 
Given an array and a value, remove all instances of that value in place and return the new length.The order of elements can be changed. It doesn't matter what you leave beyond the new length.

class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        int length = 0;
        int index = 0;
        for(int i=0; i<nums.size(); i++){
            if(nums[i] != val){
                nums[index] = nums[i];
                length++;
                index++;
            }
        }
        return length;
    }
}


Remove Duplicates from Sorted Array 
Given a sorted array, remove the duplicates in place such that each element appear only once and return the new length.Do not allocate extra space for another array, you must do this in place with constant memory.For example,Given input array nums = [1,1,2],Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively. It doesn't matter what you leave beyond the new length.

class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        if(nums.size() == 0)
            return 0;
        int length = 1;
        int index = 0;
        for(int i=1; i<nums.size(); i++){
            if(nums[i] != nums[index]){
                nums[++index] = nums[i];
                length++;
            }
        }
        return length;
    }
}


4Sum 
Given an array S of n integers, are there elements a, b, c, and d in S such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.
Note:Elements in a quadruplet (a,b,c,d) must be in non-descending order. (ie, a ≤ b ≤ c ≤ d)The solution set must not contain duplicate quadruplets.    For example, given array S = {1 0 -1 0 -2 2}, and target = 0.    A solution set is:    (-1,  0, 0, 1)    (-2, -1, 1, 2)    (-2,  0, 0, 2)

class Solution {
public:
    //先排序，在将4sum转3sum，再转2sum
    vector<vector<int>> fourSum(vector<int>& nums, int target) {
        sort(nums.begin(), nums.end());
        vector<vector<int> > ret;
        int sum = 0;
        for(int i=0; i<nums.size(); i++){
            //第一个元素去重
            if(i>0 && nums[i] == nums[i-1])
                continue;
            //剪枝
            if(nums[i]>=target && i+1<nums.size() && nums[i+1]>0)
                break;
            
            for(int j=i+1; j<nums.size(); j++){
                //第二个元素去重
                if(j>i+1 && nums[j] == nums[j-1])
                    continue;
                
                //剪枝
                if(nums[i]+nums[j]>=target && j+1<nums.size() && nums[j+1]>0)
                    break;
                int left = j+1;
                int right = nums.size()-1;
                
                while(left<right){
                    //第三个元素去重
                    if(left>j+1 && nums[left] == nums[left-1]){
                        left++;
                        continue;
                    }
                    //剪枝
                    if(nums[i]+nums[j]+nums[left]>=target && left+1<nums.size() && nums[left+1]>0)
                        break;
                    if(nums[i]+nums[j]+nums[left]+nums[right] == target){
                        vector<int> temp;
                        temp.push_back(nums[i]);
                        temp.push_back(nums[j]);
                        temp.push_back(nums[left]);
                        temp.push_back(nums[right]);
                        ret.push_back(temp);
                        left++;
                        right--;
                        continue;
                    }
                    if(nums[i]+nums[j]+nums[left]+nums[right] > target)
                        right--;
                    else
                        left++;
                    
                }
            }
            
        }
        return ret;
    }
}


3Sum Closest 
Given an array S of n integers, find three integers in S such that the sum is closest to a given number, target. Return the sum of the three integers. You may assume that each input would have exactly one solution.    For example, given array S = {-1 2 1 -4}, and target = 1.    The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).

class Solution {
public:
    //该题目想要的是最近的元素和，所以不太好使用map，因为map是针对一个特定的数字来的，这里想要的是最近似的值，所以map不太好使用
    //还是先对数组进行排序，再将3sum转换为2sum，同时进行去重，减少没必要的计算，该题目还是要将数组遍历到底，因为要找的是最近的，除非
    //找到了一个与target相等的三元组和，否则的话，遍历到底，返回最近的和。
    int threeSumClosest(vector<int>& nums, int target) {
        sort(nums.begin(), nums.end());
        //防止溢出
        long long sum = 0;
        int diff = INT_MAX;
        for(int i=0; i<nums.size(); i++){
            //第一个元素去重
            if(i>0 && nums[i]  == nums[i-1])
                continue;
            //2sum
            int left = i+1;
            int right = nums.size()-1;
            while(left<right){
                if(left > i+1 && nums[left] == nums[left-1]){
                    left++;
                    continue;
                }
                
                if(nums[i]+nums[left]+nums[right] == target)
                    return target;
                if(diff>abs(nums[i]+nums[left]+nums[right] - target)){
                    sum = nums[i]+nums[left]+nums[right];
                    diff = abs(nums[i]+nums[left]+nums[right] - target);
                }
                    
                if(nums[i]+nums[left]+nums[right]>target)
                    right--;
                else
                    left++;

            }
        }
        return sum;
    }
}


3Sum 
Given an array S of n integers, are there elements a, b, c in S such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.
Note:Elements in a triplet (a,b,c) must be in non-descending order. (ie, a ≤ b ≤ c)The solution set must not contain duplicate triplets.    For example, given array S = {-1 0 1 2 -1 -4},    A solution set is:    (-1, 0, 1)    (-1, -1, 2)

class Solution {
public:
    //可以将3sum转换为2sum，对于2sum，最好的算法就是利用map，此时只需要O(N)的时间复杂度，但所得到的二元对不一定是不递减的。
    //也可以对数组先进行排序，此时利用头尾两个指标可以得到对应的二元组，并且保证所得到的二元对是不递减的，符合题目的要求
    //对于这道题，可以先对数组进行排序，然后先确定第一个数，再对剩下的数组进行2sum查找，总时间复杂度为O(N^2)
    vector<vector<int>> threeSum(vector<int>& nums) {
        if(nums.size()<3)
            return {};
        sort(nums.begin(), nums.end());
        vector<vector<int> > ret;
        for(int i=0; i<nums.size(); i++){
            //第一个元素去重
            if(i>0 && nums[i] == nums[i-1])
                continue;
            //接下来是2sums
            int left = i+1;
            int right = nums.size()-1;
            while(left<right){
                //二元组的第一个元素去重
                if(left>i+1 && nums[left] == nums[left-1]){
                    left++;
                    continue;
                }
                if(nums[i] + nums[left] + nums[right] == 0){
                    vector<int> temp;
                    temp.push_back(nums[i]);
                    temp.push_back(nums[left]);
                    temp.push_back(nums[right]);
                    ret.push_back(temp);
                    left++;
                    right--;
                    continue;
                }
                if(nums[i] + nums[left] + nums[right] > 0)
                    right--;
                else
                    left++;
                    
            }
        }
        
        return ret;
    }
}


Container With Most Water 
Given n non-negative integers a1, a2, ..., an, where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.
Note: You may not slant the container.

class Solution {
public:
    //从数组的两边向中间收缩，对于左边界left和右边界right，如果height[left]<height[right]
    //那么说明以left作为起始边的container的最大值也就是以right为结束边时所获得的容量，对于right也是一样的道理
    int maxArea(vector<int>& height) {
        if(height.size() <= 1)
            return 0;
        int largest = 0;
        int left = 0, right = height.size()-1;
        while(left < right){
            int contain = min(height[left], height[right])*(right-left);
            if(largest < contain)
                largest = contain;
            if(height[left] < height[right])
                left++;
            else
                right--;
        }
        return largest;
    }
}


Median of Two Sorted Arrays 
There are two sorted arrays nums1 and nums2 of size m and n respectively. Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).

class Solution {
public:
    //将该问题 转换为寻找第K小的问题
    /*
    首先假设数组A和B的元素个数都大于k/2，我们比较A[k/2-1]和B[k/2-1]两个元素，这两个元素分别表示A的第k/2小的元素和B的第k/2小的元素。这两个元素比较共有三种情况：>、<和=。如果A[k/2-1]<B[k/2-1]，这表示A[0]到A[k/2-1]的元素都在A和B合并之后的前k小的元素中。换句话说，A[k/2-1]不可能大于两数组合并之后的第k小值，所以我们可以将其抛弃。

    证明也很简单，可以采用反证法。假设A[k/2-1]大于合并之后的第k小值，我们不妨假定其为第（k+1）小值。由于A[k/2-1]小于B[k/2-1]，所以B[k/2-1]至少是第（k+2）小值。但实际上，在A中至多存在k/2-1个元素小于A[k/2-1]，B中也至多存在k/2-1个元素小于A[k/2-1]，所以小于A[k/2-1]的元素个数至多有k/2+ k/2-2，小于k，这与A[k/2-1]是第（k+1）的数矛盾。

    当A[k/2-1]>B[k/2-1]时存在类似的结论。

    当A[k/2-1]=B[k/2-1]时，我们已经找到了第k小的数，也即这个相等的元素，我们将其记为m。由于在A和B中分别有k/2-1个元素小于m，所以m即是第k小的数。(这里可能有人会有疑问，如果k为奇数，则m不是中位数。这里是进行了理想化考虑，在实际代码中略有不同，是先求k/2，然后利用k-k/2获得另一个数。)

    通过上面的分析，我们即可以采用递归的方式实现寻找第k小的数。此外我们还需要考虑几个边界条件：

    如果A或者B为空，则直接返回B[k-1]或者A[k-1]；
    如果k为1，我们只需要返回A[0]和B[0]中的较小值；
    如果A[k/2-1]=B[k/2-1]，返回其中一个；
    */
    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
        int total = nums1.size() + nums2.size();
        if(total & 1)
            return findK(nums1, 0, nums2, 0, total/2+1 );
        return (findK(nums1, 0, nums2, 0, total/2) + findK(nums1, 0, nums2, 0, total/2+1))/2;
    }
    
    double findK(vector<int> &nums1, int start1, vector<int> &nums2, int start2, int k){
        if(nums1.size()-start1 > nums2.size()-start2)
            return findK(nums2, start2, nums1, start1, k);
        if(start1 == nums1.size())
            return nums2[start2+k-1];
        if(k == 1)
            return min(nums1[start1], nums2[start2]);
        int ka = min(k/2, (int)nums1.size()-start1), kb = k - ka;
        if(nums1[start1+ka-1] == nums2[start2+kb-1])
            return nums1[start1+ka-1];
        if(nums1[start1+ka-1] < nums2[start2+kb-1])
            return findK(nums1, start1+ka, nums2, start2, k-ka);
        return findK(nums1, start1, nums2, start2+kb, k-kb);
    }
}


Two Sum 
Given an array of integers, find two numbers such that they add up to a specific target number.The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based.You may assume that each input would have exactly one solution.Input: numbers={2, 7, 11, 15}, target=9Output: index1=1, index2=2

class Solution {
public:
    //利用map的hash特性，查找一个数只需要常量的时间，利用map来查找target-nums[i]，只需要常量的时间，这样可以实现O(n)的时间复杂度。
    vector<int> twoSum(vector<int>& nums, int target) {
        if(nums.size() == 0)
            return {};
        map<int, int> search;
        vector<int> ret;
        for(int i=0; i<nums.size(); i++){
            int anOther = target-nums[i];
            if(search.find(anOther) != search.end()){
                ret.push_back(search[anOther]);
                ret.push_back(i+1);
                return ret;
            }
            search[nums[i]] = i+1;
        }
        return ret;
    }
}


